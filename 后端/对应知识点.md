### 1. restful风格

1）域名 : 应该尽量将API部署在专用域名之下 ：  http://api.hello.com 

2）版本: 应该将API的版本号放入URL： http://api.rock.com/v1/

3）路径（Endpoint）：不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应

4）资源操作：对于资源的具体操作类型，由HTTP动词表示

5）过滤信息：如果记录数量过多，服务器不可能将它们返回给用户： ?page=2&per\_page=20

6）返回结果

​			针对不同操作，服务器向用户返回的结果应该符合以下规范

​				GET /sutdents：返回资源对象的列表（数组，集合）

​				GET /sutdents/id：返回单个资源对象

​				POST /sutdents：返回新生成的资源对象

​				PUT /sutdents/id：修改资源，返回完整的资源对象

​				PATCH /sutdents/id：修改资源，返回完整的资源对象

​				DELETE /sutdents/id：返回一个空文档



### 2.自定义JWT及认证

```python
'''
生成token
'''
# 生成token
	def create_token(uid):
		part1 = {
			'typ': 'JWT',
			'alg': 'HS256'
		}

		part2 = {
			'uid': uid
		}

		b64_part1 = base64.b64encode(json.dumps(part1).encode()).decode()
		b64_part2 = base64.b64encode(json.dumps(part2).encode()).decode()

		part3 = b64_part1+b64_part2+settings.SECRET_KEY
		sha = hashlib.sha256()
		sha.update(part3.encode())

		sha_part3 = sha.hexdigest()

		token = f"{b64_part1}.{b64_part2}.{sha_part3}"

		return token
    
    
'''
验证token
'''    
# 验证token
	def check_token(token):
		token_split = token.split('.')

		code = token_split[0]+token_split[1]+settings.SECRET_KEY
		sha = hashlib.sha256()
		sha.update(code.encode())
		sha_code = sha.hexdigest()

		if sha_code == token_split[2]:
			return True, token_split[1]
		else:
			return False, token_split[1]	
			
	
	
	在中间件使用：
	    def process_request(self, request):

            # 发短信和登陆接口是 不需要 判断用户有没有登陆

            url = request.path


            # 如果 返回None， 就继续往下走，
            # 如何返回响应对象，就直接返回结果，不会执行视图函数

            if url in self.white_url:
                return

            token = request.META.get('HTTP_AUTHORIZATION')

            if not token:
                return render_json('用户未登陆', error.USER_NOT_LOGIN)

            res, payload = check_token(token)
            if res:
                # 成功, 取出载荷 中的uid
                data = json.loads(base64.b64decode(payload))
                uid = data.get('uid')
                request.user = User.objects.get(id=uid)

            else:
                return JsonResponse('身份验证失败', error.VERFY_USER_FAIL)



```



### 3.mysql随机取数据

```python
	# mysql中 随机 取数据
    # select * from table order by rand()
	# select * from Score order by rand() limit 5

    # django使用 100w以下的小数据量可以用 order_by('?')
    # users = users.order_by('?')[:20]

    # 大数据量一般先 取样， 然后 通过 切片 取 1条数据
    lis = list(range(0, users.count()))
    sam = random.sample(lis, 10)
    users = [users.all()[i] for i in sam]
```





### 4.MYSQL优化及主从复制读写分离

#### 4.1 mysql优化

```python
'''
1、创建索引(B+树)
什么时候加索引：where 查询语句后面经常出现的字段，就要加索引
判断索引是否起作用：通过explain 语法来测试 索引有没有用 看rows的记录
				其中：or、!=、<>、is null、 like '%xxx'  用不到索引

2、通过慢查询日志来检查执行比较慢的sql语句
	设置慢查询的时间，比如5s，那么超过5s，日志会记录这个语句
	> show variables like "%slow%";  --查询是否开启慢查询日志
	
	在mysql配置文件my.cnf：
        增加slow_query_log=1开启慢查询日志，
        long_query_time=1,查询超过多长时间记录，
        log_queries_not_using_indexes=1,记录没有索引的查询
        
3、分库：主从复制、读写分离




4、分表：
    垂直分表
    单表字段太多的时候会进行垂直拆分, 常用的字段放在一张表了，不常用的字段放在另外一张表里
                                      垂直拆分
                                       |
        user                           | ext_info
                                       |
        | id  name  sex  age  location | uid aa  bb  cc  dd  ee  ff |
        | ---------------------------- | -------------------------- |
        | 1   xxx   f    11   beijing  | 1  x   x   x   x   x   x   |
        | 2   xxx   f    11   beijing  | 2  x   x   x   x   x   x   |
        | 3   xxx   f    11   beijing  | 3  x   x   x   x   x   x   |
        | 4   xxx   f    11   beijing  | 4  x   x   x   x   x   x   |
        | 5   xxx   f    11   beijing  | 5  x   x   x   x   x   x   |
        | 6   xxx   f    11   beijing  | 6  x   x   x   x   x   x   |
        | 7   xxx   f    11   beijing  | 7  x   x   x   x   x   x   |
        | 8   xxx   f    11   beijing  | 8  x   x   x   x   x   x   |
        | 9   xxx   f    11   beijing  | 9  x   x   x   x   x   x   |
        
        
	水平切分： mysql8单张表的记录：7、8千W
        1、按范围拆分  
              - 优点: 构建简单, 扩容极其方便；查询的时候必须使用id进行查询，否则不知道哪张表
              - 缺点: 不能随运营发展均衡分配资源
              table-1       1 -  500W   <- uid: 3120482
        	  table-2    500W - 1000W
      		  table-3   1000W - 1500W   <- uid: 10278327
        	  table-4   1500W - 2000W
        	  
        2、按余数拆分
        	优点: 能够随着运营发展均匀分配负载
			缺点: 扩容不方便, 前期投入大；
			重点：如果后期加入新的数据库服务器，可以用按范围的方式存到新的服务器里
			
			uid = 3120483
            mod = uid % len(Databases) -> 3
            db_name = 'Database-3'

            Database-0      10  20  30   ...  3120480
            Database-1   1  11  21  31   ...  3120481
            Database-2   2  12  22  32   ...  3120482
            Database-3   3  13  23  33   ...  3120483
            

		3、一致性hash
          	- 优点：极易扩展，资源均匀分配
        	- 缺点：小规模的部署性能不高        
        
'''


import zlib

class VirNode:

    def __init__(self):
        self.node = {}

    def crcEncode(self, data):
        return zlib.crc32(str(data).encode())

    # 增加节点
    def addNode(self, server):

        # crc32的值为键，server的名字为值
        for i in range(20):
            key = self.crcEncode(f"{server}-{i}")
            self.node[key] = server

    # 排序
    def sortNode(self):
        return dict(sorted(self.node.items()))

    # 找数据对应的是哪个服务器
    def search(self, data):
        data = self.crcEncode(data)
        print(f'data的 crc32 的值是 {data}')
        sortDict = self.sortNode()

        for k, v in sortDict.items():
            if k > data:
                node = v
                break
        else:
            node = sortDict.get(min(sortDict))

        return node


    # 测试，打印所有的节点
    def printNodes(self):
        print('全部节点:%s' % self.sortNode())



node = VirNode()
node.addNode('10.96.54.102')
node.addNode('10.96.54.103')
node.addNode('10.96.54.104')
node.printNodes()
print(node.search(404))





# crc32
# 作为数据的检测
# 作为一致性hash数据的分布
```



#### 4.2 主从复制、读写分离

##### **1.主从同步介绍和优点**

- 在多台数据服务器中，分为主服务器和从服务器。一台主服务器对应多台从服务器。
- 主服务器只负责写入数据，从服务器只负责同步主服务器的数据，并让外部程序读取数据。
- 主服务器写入数据后，即刻将写入数据的命令发送给从服务器，从而使得主从数据同步。
- 应用程序可以随机读取某一台从服务器的数据，这样就可以分摊读取数据的压力。
- 当从服务器不能工作时，整个系统将不受影响；当主服务器不能工作时，可以方便地从从服务器选举一台来当主服务器
- 使用主从同步的优点：
  - 提高读写性能
    - 因为主从同步之后，数据写入和读取是在不同的服务器上进行的，而且可以通过增加从服务器来提高数据库的读取性能。
  - 提高数据安全
    - 因为数据已复制到从服务器，可以在从服务器上备份而不破坏主服务器相应数据。



##### **2.主从同步机制**

MySQL服务器之间的主从同步是基于**二进制日志机制**，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。



##### **3. 基于 Docker 来搭建 MySQL 的主从复制**

1. 准备两台 MySQL 服务器
2. 配置主服务器（Master）
3. 配置从服务器（Slave）
4. 完成Master和Slave链接
5. 测试配置是否成功



###### **3.1.准备两台 MySQL 服务器**

- 使用 Docker 创建 MySQL 的master服务器：

  ```bash
  sudo docker run --name mysql_master -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27
  ```

- 使用同样的方式创建 Slave 服务器：

  ```bash
  sudo docker run --name mysql_slave -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.27
  ```

- 使用 `sudo docker ps` 查看当前运行的容器，如下：

![image-20190903203535964](C:/Users/Administrator/Desktop/7.综述/day09_docker、Fastdfs、mysql主从及django配置/资料/docker资料/es.assets/image-20190903203535964.png)



###### 3.2 配置主服务器（Master）

- 首先，进入到 Master 服务器

  ```bash
  sudo docker exec -it mysql_master /bin/bash
  ```

- 修改配置文件/etc/mysql/mysql.conf.d/mysqld.conf

  ```bash
  # 在末尾加上两个配置
  
  ## 设置server_id，一般设置为IP的最后一位，同一局域网内注意要唯一
  server_id = 3
  
  ## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）
  log-bin = edu-mysql-bin
  ```

  > 注意：修改文件的时候，可能没有vi命令，需要安装vim的软件包
  >
  > 方法：apt-get update     apt install vim

  

- 配置完成后重启 mysql

  ```bash
  service mysql restart
  ```

  > 注意：这个命令会使得容器停止，重新启动就可以了。

  

- 进入mysql数据库中创建数据同步用户

  ```bash
  mysql -u root -p -h 172.16.222.152 --port=3307
  ```

  

- 创建数据同步用户

  ```bash
  mysql> CREATE USER 'slave'@'%' IDENTIFIED BY '123456';
  mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%'; 
  ```



###### **3.3 配置从服务器（Slave）**

- 首先，进入到 Master 服务器

  ```bash
  sudo docker exec -it mysql_slave /bin/bash
  ```

- 修改配置文件/etc/mysql/mysql.conf.d/mysqld.conf

  ```bash
  # 在末尾加上两个配置
  
  ## 设置server_id，一般设置为IP的最后一位，同一局域网内注意要唯一
  server_id = 4
  
  ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用
  log-bin=edu-mysql-slave-bin  
  ```

- 配置完成后重启mysql，和配置 Master 一样，会使容器停止，需要启动容器。

  ```bash
  service mysql restart
  ```



###### 3.4 完成Master和Slave链接

- 在 Master 进入 MySQL， 然后执行命令：

  ```bash
  mysql -u root -p -h 172.16.222.152 --port=3307
  
  mysql> show master status;
  ```

  结果如下：

  ![image-20190903205334801](C:/Users/Administrator/Desktop/7.综述/day09_docker、Fastdfs、mysql主从及django配置/资料/docker资料/es.assets/image-20190903205334801.png)

  记录下 File 和 Position 字段的值，后面会用到。

  

- 然后到 Slave 中进入 mysql，执行命令：

  ```bash
  mysql -u root -p -h 172.16.222.152 --port=3308
  
  mysql> change master to master_host='172.16.222.152', master_user='slave', master_password='123456', master_port=3307, master_log_file='edu-mysql-bin.000001', master_log_pos=34659, master_connect_retry=30;
  ```

  命令解释：

  ```bash
  master_host: Master 的IP地址
  master_user: 在 Master 中授权的用于数据同步的用户
  master_password: 同步数据的用户的密码
  master_port: Master 的数据库的端口号
  master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值
  master_log_pos: 从哪个 Position 开始读，即上文中提到的 Position 字段的值
  master_connect_retry: 当重新建立主从连接时，如果连接失败，重试的时间间隔，单位是秒，默认是60秒。
  ```

- 在 Slave 的 MySQL 终端执行查看主从同步状态

  ```bash
  show slave status \G;
  ```

  ![image-20190903205811370](C:/Users/Administrator/Desktop/7.综述/day09_docker、Fastdfs、mysql主从及django配置/资料/docker资料/es.assets/image-20190903205811370.png)

> SlaveIORunning 和 SlaveSQLRunning 是No，表明 Slave 还没有开始复制过程。相反 SlaveIORunning 和 SlaveSQLRunning 是Yes表明已经开始工作了，因为我已经运行过了，所以我的显示的都是 Yes。

- 执行以下命令，开始开启主从同步：

  ```bash
  start slave;
  ```





在做主从同步时，如果从机需要主机上原有数据，就要先复制一份到从机。

- 收集主机原有数据

  ```python
  mysqldump -uroot -p swiper_1906 > swiper.sql
  ```

- 从机复制主机原有数据

  ```python
  mysql -uroot -p -h172.16.222.176 --port=3307 swiper < swiper.sql
  ```

  

注意：如果停止容器后，在启动。启动不成功，说明容器中的配置文件有语法错误

- 怎么检查配置文件的语法错误？

  ```python
  sudo docker logs 不能启动容器的id
  ```

- 怎么修改配置文件

  - 把容器中错误的配置文件，复制到宿主机

    ```python
    sudo docker cp 容器名称:配置文件的位置 宿主机保存文件的位置
    ```

  - 复制完后，修改配置文件。然后在 复制回容器原来的位置

    ```python 
    sudo docker cp 宿主机保存文件的位置 容器名称:配置文件的位置
    ```

    



##### 4. Django实现MySQL读写分离

###### 1. 增加slave数据库的配置

```python
DATABASES = {
    'default': { # 写（主机）
        'ENGINE': 'django.db.backends.mysql', # 数据库引擎
        'HOST': '172.16.222.152', # 数据库主机
        'PORT': 3307, # 数据库端口
        'USER': 'root', # 数据库用户名
        'PASSWORD': '123456', # 数据库用户密码
        'NAME': 'sz1903' # 数据库名字
    },
    'slave': { # 读（从机）
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '172.16.222.152',
        'PORT': 3308,
        'USER': 'root',
        'PASSWORD': '123456',
        'NAME': 'sz1903'
    }
}
```



###### 2. 创建和配置数据库读写路由

> **1.创建数据库读写路由**
>
> - 在`common/db_router.py`中实现读写路由

```python
class MasterSlaveDBRouter(object):
    """数据库读写路由"""

    def db_for_read(self, model, **hints):
        """读"""
        return "slave"

    def db_for_write(self, model, **hints):
        """写"""
        return "default"

    def allow_relation(self, obj1, obj2, **hints):
        """是否运行关联操作"""
        return True
```



> **2.配置数据库读写路由settings**

```python
DATABASE_ROUTERS = ['common.db_router.MasterSlaveDBRouter']
```



###### 3.django执行原生sql

```python
from django.db import connections

with connections['...'].cursor() as cursor:
    cursor.execute("UPDATE TbEmp SET sal=sal+10 WHERE dno=30")
    cursor.execute("SELECT ename, job FROM TbEmp WHERE dno=10")
    row = cursor.fetchall()
```



### 5.celery 异步任务

```python
'''
- 任务模块 Task
  包含异步任务和定时任务. 其中, 异步任务通常在业务逻辑中被触发并发往任务队列, 而定时任务由 Celery Beat 进程周期性地将任务发往任务队列.
  
- 消息中间件 Broker
  Broker, 即为任务调度队列, 接收任务生产者发来的消息（即任务）, 将任务存入队列. Celery 本身不提供队列服务, 官方推荐使用 RabbitMQ 和 Redis 等.
  
- 任务执行单元 Worker
  Worker 是执行任务的处理单元, 它实时监控消息队列, 获取队列中调度的任务, 并执行它.
  
- 任务结果存储 Backend
  Backend 用于存储任务的执行结果, 以供查询. 同消息中间件一样, 存储也可使用 RabbitMQ, Redis 和 MongoDB 等.
'''
```

![1578153633810](C:\Users\Administrator\Desktop\简历\image\celery.png)



![1578153697144](C:\Users\Administrator\Desktop\简历\image\celery使用场景.png)



#### 5.1 异步任务

```python
'''
1、celery安装配置
'''

pip install celery[redis]
pip install redis  # redis驱动

# 消息中间件  rabbitMQ/redis



'''
2、创建实例及任务
task.py
'''

import time
from celery import Celery

broker = 'redis://localhost:6379/1'
backend = 'redis://localhost:6379/2'
app = Celery('my_task', broker=broker, backend=backend)

@app.task
def add(x, y):
    time.sleep(4)
    return x + y


'''
3、调用任务
app.py
'''
from task import add

if __name__ == '__main__':
    print('start task...')
    result = add.delay(2, 8)
    print('end task...')
    # print(result)




# 启动celery
celery worker -A  实例创建的文件 -l info
celery worker -A  task -l info
-A 指定 实例创建的位置
-l 指定 日志级别


linux：
	celery worker -A tasks -l info
windows:
    pip install eventlet
    celery worker -A tasks -l info -P eventlet

```



#### 5.2 定时任务

分别启动beat、worker:

celery beat -A celery_app  -l info

celery worker -A tasks -l info -P eventlet



一条命令启动beat、worker【在windows无效】:

celery -B  -A celery_app  worker   -l info

- ##### celery定时执行任务

  - 在worker包中的`__init__`文件中加入如下配置

    ```python
    from celery.schedules import crontab
    from datetime import timedelta
    
    ...
    ...
    ...
    
    celery_app.conf.update(   # 固定写法
        CELERYBEAT_SCHEDULE={ # 固定写法
            'sum-task': {  # 名字随便命名
                'task': 'common.func.add',  # 导入异步任务
                'schedule': timedelta(seconds=5), # 定时时间
                'args': (5, 6)  # 异步任务函数的参数
            }
        }
    )
    
    '''
    schedule中定时时间有两种方式
    - timedelta方法
        days：天
        seconds：秒
        microseconds：微妙
        milliseconds：毫秒
        minutes：分
        hours：小时	
    - crontab方法
    	month_of_year：月份
        day_of_month：日期
        day_of_week：周
        hour：小时
        minute：分钟
        
        例子
        crontab()  每分钟
        crontab(minute=0, hour=0)  每天的0时0分
        crontab(minute=0, hour='*/3')  每三小时
        crontab(day_of_week='sunday')  周日的每一小时
        crontab(minute='*',hour='*', day_of_week='sun') 与上面相同
    '''
    ```

  - 在common包的func.py中定义add异步任务

    ```python
    @celery_app.task
    def add(x,y):
        return x * y
    ```

  - 同时启动worker和定时任务

    ```python
    celery worker -A worker -l info -B
    ```





- ##### Linux定时任务：contrab

  - 判断cron服务有没有启动，命令：

    ps -ef | grep cron

    启动命令：sudo service cron start

    关闭命令：sudo service cron stop

    重启命令：sudo service cron restart

    重新载入配置文件：sudo service cron reload

     

  - 编辑crontab

    命令：sudo crontab -e

    第一次编辑crontab，会让我们选择使用的编辑器，一般选择第三个vim

    如果选错了，可以执行sudo select-editor 重新选择

    进入编辑页面就可以添加执行的任务

   

  - 查看crontab任务

    命令：sudo crontab -l

    会列出当前用户添加的所有任务

   

  - 清空crontab任务

    命令：sudo crontab -r

    删除当前用户设置的所有任务

    

  - 配置说明

    - 1-10   */2   *   *   *   python3 /etc/a.py

    - crontab中的每一行代表一个定期执行的任务，分为6个部分。前5个部分表示何时执行命令，最后一个部分表示执行的命令。

    - 每个部分以空格分隔，除了最后一个部分（命令）可以在内部使用空格之外，其他部分都不能使用空格。

    - 前5个部分分别代表：分钟，小时，天，月，星期，每个部分的取值范围如下：

      - 分钟         0 - 59
      - 小时         0 - 23
      - 天           1 - 31
      - 月           1 - 12
      - 星期         0 - 6       0表示星期天

    - 除了这些固定值外，还可以配合星号（*），逗号（,），短横线（-）和斜线（/）来表示一些其他的含义：

      - 星号：表示任意值，比如在小时部分填写* 代表任意小时（每小时）

      - 逗号：可以允许在一个部分中填写多个值，比如在分钟部分填写1,3 表示一分钟或三分钟

      - 斜线：一般配合* 使用，代表每隔多长时间，比如在小时部分填写`*/2` 代表每隔两小时。所以`*/1` 和* 没有区别

      - 短横线：表示范围，比如在分钟部分填写1-10 代表从第一分钟到第十分钟

        

  - 例子: 

    ```python
    #每天早上7点
    0 7 * * * 
    
    #在12 月内, 每天的早上6 点到12 点中，每隔3个小时执行一次
    0 6-12/3  * 12 *
     
    #周一到周五每天下午5:00
    0 17 * * 1-5
    
    #每月每天的午夜0 点20 分, 2 点20 分, 4 点20 分...
    20 0-23/2 * * *
    
    #每小时的第10和第15分钟
    10,15 * * * *
    
    #每分钟执行一次
    * * * * * 
    
    # 每一秒钟执行一次
    在代码里加入
    for i in range(60):
    	time.sleep(1)
        print('fffff')
    ```





- ##### django中的定时任务

  - 1.安装 django-crontab

    ```python
    pip install django-crontab
    ```

  - 2.注册 django-crontab 应用

    ```python
    INSTALLED_APPS = [    
        'django_crontab', # 定时任务
    ]
    ```

  - 3.设置定时任务

    ```python
    定时时间基本格式 :
    
    *  *  *  *  *
    
    分 时 日  月  周    命令
    
    M: 分钟（0-59）。每分钟用 * 或者 */1 表示
    H：小时（0-23）。（0表示0点）
    D：天（1-31）。
    m: 月（1-12）。
    d: 一星期内的天（0~6，0为星期天）。
      
      
    在配置文件settings中定义
    CRONJOBS = [
        ('* * * * *', 'common.func.print_info')
    ]
    
    
    解决 crontab 中文问题
    在定时任务中，如果出现非英文字符，会出现字符异常错误
    CRONTAB_COMMAND_PREFIX = 'LANG_ALL=zh_cn.UTF-8'
    ```

  - 4.管理定时任务

    ```python
    # 添加定时任务到系统中
    python manage.py crontab add
    
    # 显示已激活的定时任务
    python manage.py crontab show
    
    # 移除定时任务
    python manage.py crontab remove
    ```









#### 5.3 django中使用celery

```python
pip install django-celery  # 安装模块

python  manage.py celery worker -l info
# 使用manage启动worker

# 注意redis驱动版本不能太高 否则报： 'str' object has no attribute 'items'
pip install redis==2.10.6
```



#### 5.4  flower任务监控工具

```python
# 安装
pip install flower==0.9

# 启动flower
python manage.py  celery flower 

# 打开 http://localhost:5555可以查看任务执行情况

# 加入认证
python manage.py  celery flower --basic_auth=Blog:Blog
# 打开 http://localhost:5555可以查看任务执行情况时需要登录认证 ==> 账户/密码:Blog:Blog
```



#### 5.5 supervisor进程管理部署celery

echo_supervisord_conf > conf/supervisord.con





### 6.nginx、uWSGI与gunicorn配置

#### 6.1 nginx配置

 使用最多的三个核心功能是反向代理、负载均衡和静态服务器 

 

正向代理就是顺着请求的方向进行的代理，即**【代理服务器他是由你配置为你服务】**，去请求目标服务器地址 

 比如我们要去访问谷歌网站，我们直接访问不通，那么我们就可以找一个代理服务器为我们服务，我们通过代理服务器请求到谷歌网站。对于谷歌而言他只知道有一个服务器访问了自己​，并不知道这件事你是访问不了他,找了一个代理服务器访问自己。 

 ![img](https://img-blog.csdnimg.cn/20190531180703829.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70) 



##### 正向代理：

```python
'''
resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，
配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了
'''


server {
    listen       80;
    server_name  149.129.109.88;

    resolver 8.8.8.8;
    location / {
        proxy_pass http://$http_host$request_uri;
    }
}
```



##### 反向代理及静态文件：

 反向代理正好与正向代理相反，代理服务器是为目标服务器服务的，虽然整体的请求返回路线都是一样的都是Client到Proxy到Server 

 比如 我们访问百度网站，百度的代理服务器对外的域名为 https://www.baidu.com 。具体内部的服务器节点我们不知道。现实中我们通过访问百度的代理服务器后，代理服务器给我们转发请求到他们N多的服务器节点中的一个给我们进行搜索后将结果返回 

 ![img](https://img-blog.csdnimg.cn/20190531180723798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhlbmdodWk1MjAx,size_16,color_FFFFFF,t_70) 

```python
server {
        listen       80;
        server_name 127.0.0.1;
        location / {
			include /etc/nginx/uwsgi_params;
			uwsgi_pass localhost:8010;
        }
    
    	# 将http -> server 中的location/static配置
		location /static {
			alias /var/www/DjangoAXF/AXF/static/;
		}

    }
```



##### 负载均衡

```python
'''
1、轮询，在nginx 的配置文件里面配置
效果：在设置的服务器之间轮询访问
'''
http {
   
    upstream blog{
        server 172.16.222.176:8000;
        server 127.0.0.1:8000;
    }
}


'''
2、权重：weight的值越大，访问的频率越高
'''

http {

    upstream blog{
        server 172.16.222.176:8000 weight=1;
        server 127.0.0.1:8000 weight=10;
    }
}


'''
3、ip_hash
效果：根据访问的ip的值通过某种计算，把ip固定访问某台服务器。实际上就是一至性hash
'''

http {
    upstream blog{
        server 172.16.222.176:8000;
        server 127.0.0.1:8000;
      	ip_hash;
    }
}
```



配置一个负载均衡的反向代理服务器

```python
http{
    
    upstream blog{
        server 172.16.222.176:8000;
        server 127.0.0.1:8000;
      	ip_hash;
    }
    
    
    server {
        listen 80;
        server_name  b.cc;
        charset utf-8;
        access_log  /var/log/nginx/b-access.log;
        error_log  /var/log/nginx/b-err.log;

        location / {
            proxy_pass http://blog; # 这里要配合启动文件使用
            proxy_redirect     off;
            proxy_set_header   Host                 $http_host;
            proxy_set_header   X-Real-IP            $remote_addr;
            proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Proto    $scheme;
        }

    }
}


```





#### 6.2 多个server

```python
http{
    server {
        listen       80;
        server_name 127.0.0.1;
        location / {
			include /etc/nginx/uwsgi_params;
			uwsgi_pass localhost:8010;
        }

    };

    server {
            listen       8081;
            server_name 127.0.0.1;
            location / {
                include /etc/nginx/uwsgi_params;
                uwsgi_pass localhost:8011;
            }
        }   
}
```



```python
http{

	include servers/*;
}

# 在servers目录配置
```



#### 6.3 nginx热启动

```python
'''
Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效
'''
nginx -s reload
```





#### 6.4 uWSGI配置

##### 1. 安装uwsgi包

pip install uwsgi



##### 2.准备uwsgi服务器配置文件uwsgi.ini

```python
[uwsgi]
# 使用Nginx连接时使用，Django程序所在服务器地址
socket=127.0.0.1:9999
# 直接做web服务器使用，Django程序所在服务器地址
# http=127.0.0.1:9999
# 项目目录
chdir=/Users/apple/program/python/Desktop/django/swiper/swiper
# 项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=swiper/wsgi.py
# 进程数
processes=4
# 线程数
threads=2
# uwsgi服务器的角色
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件
daemonize=uwsgi.log
# 虚拟环境路径
virtualenv=/Users/apple/Envs/swiper
```



##### 3.管理uwsgi服务器

```python
# 启动
$ uwsgi --ini uwsgi.ini
# 关闭
$ uwsgi --stop uwsgi.pid
```





#### 6.5 gunicorn配置

1. 安装gunicorn和gevent包

   ```python
   pip install gunicorn gevent
   ```

2. 配置文件主项目目录下`gunicorn-config.py`

   ```python
   from multiprocessing import cpu_count
   
   bind = ["127.0.0.1:9999"]  # 线上环境不会开启在公网 IP 下，一般使用内网 IP
   daemon = True  # 是否开启守护进程模式
   pidfile = 'logs/gunicorn.pid'
   
   workers = cpu_count() * 2  # 工作进程数量
   worker_class = "gevent"  # 指定一个异步处理的库
   worker_connections = 65535
   
   keepalive = 60  # 服务器保持连接的时间，能够避免频繁的三次握手过程
   timeout = 30
   graceful_timeout = 10
   forwarded_allow_ips = '*'
   
   # 日志处理
   capture_output = True
   loglevel = 'info'
   errorlog = 'logs/gunicorn-error.log'
   
   ```

3. 管理`gunicorn服务器`

   ```python
   gunicorn -c ./swiper/gunicorn-config.py swiper.wsgi
   ```

4. 修改Nginx服务器配置文件

   ```python
   server {
       listen 80;
       server_name swiper.cc;
   
       location / {
           proxy_pass http://127.0.0.1:9999;
           proxy_set_header Host $host;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       }
   }
   ```

   



### 7.代码快速同步到其他服务器

```shell
#!/bin/bash


LOCAL_DIR='../'
REMOTE_DIR='/home/python/Desktop/project'

USER='python'
HOST='172.16.222.176'

rsync -crvP $LOCAL_DIR $USER@$HOST:$REMOTE_DIR
```



scp与rsync对比

```python
'''
scp
第一次是在不存在文件夹repository情况下执行的，
第二次是存在文件夹repository情况下执行的
'''

time scp -qr repository root@mas2:/usr/nci/;
time scp -qr repository root@mas2:/usr/nci/;
    

    
'''
rsync
第一次是在不存在文件夹repository情况下执行的，
第二次是存在文件夹repository情况下执行的
'''    
time rsync -aCvq repository root@mas2:/usr/nci/;
time rsync -aCvq repository root@mas2:/usr/nci/;
   
'''
rsync和scp在文件夹均不存在时，执行时间相差不大，
但是文件夹存在的情况下差异很大原因是scp是复制：
    若文件不存在则新建，若存在则覆盖，可以理解为scp为“复制”；
    而rsync则在文件在存在于两主机时，比较两文件是否相同，相同的话，就什么都不做，若存在差异就直接更新
    简单的说rsync只对差异文件做更新
'''


```





### 8. Elasticsearch

#### 8.1 elasticsearch的概念

```python
'''
1. elasticsearsh: 分布式搜索引擎，集合了数据保存和数据分析服务的搜索引擎
2. 集群：一个或者多个节点组织在一起
3. 节点：一个节点是集群中的一个服务器，甶一个名字来标识，默认是一个随机的漫威角色的名字
4. 分片：将索引划分为多份的能力，允许水平分割和扩展容量，多个分片都可以响应请求，提高性能和吞吐量
5. 副本：创建分片的一份或多份的能力，在一个节点失败其余节点可以顶上
'''

如果你的文档是JSON的，你也可以把ElasticSearch当作一种“NoSQL数据库”， 应用ElasticSearch数据聚合分析（aggregation）的特性，针对数据进行多维度的分析

https://www.cnblogs.com/hualess/p/11540477.html  win 安装elastisearch
```



elasticsearch与mysql对应关系：

|  elasticsearch  | mysql  |
| :-------------: | :----: |
|   index(索引)   | 数据库 |
|   type(类型)    |   表   |
| documents(文档) |   行   |
|     fields      |   列   |



![elasticsearch](C:\Users\Administrator\Desktop\简历\image\elasticsearch.png)



![elasticsearch02](C:\Users\Administrator\Desktop\简历\image\elasticsearch02.png)

![elasticsearch03](C:\Users\Administrator\Desktop\简历\image\elasticsearch03.png)

![elasticsearch04](C:\Users\Administrator\Desktop\简历\image\elasticsearch04.png)



创建倒排索引，分为以下几步：

1）创建文档列表：

首先对原始文档数据进行编号（DocID），形成列表，就是一个文档列表

![es001](C:\Users\Administrator\Desktop\简历\image\es001.jpg)



2）创建倒排索引列表

然后对文档中数据进行分词，得到词条。对词条进行编号，以词条创建索引。然后记录下包含该词条的所有文档编号（及其它信息）。

![es002](C:\Users\Administrator\Desktop\简历\image\es002.jpg)

谷歌之父--> 谷歌、之父

```
搜索的过程：
当用户输入任意的词条时，首先对用户输入的数据进行分词，得到用户要搜索的所有词条，然后拿着这些词条去倒排索引列表中进行匹配。找到这些词条就能找到包含这些词条的所有文档的编号。
然后根据这些编号去文档列表中找到文档

```



#### 8.2 elasticsearch文档和索引的crud操作

```python

# 索引初始化操作
# 指定分片(shards)和副本的数量(replicas)
# shards一旦设置不能修改
PUT lagou
{
  "settings": {
    "index":{
      "number_of_shards":5,
      "number_of_replicas":1
    }
  }
}


# 获取指定索引
GET lagou
GET _all

# 获取指定索引设置信息
GET lagou/_settings
GET .kibana,lagou/_settings

# 获取所有索引设置信息
GET _all/_settings
GET _settings

# 更新指定索引设置信息
PUT lagou/_settings
{
  "number_of_replicas":1
}




# 保存文档-指定id
POST lagou/job/1
{
  "title":"python分布式爬虫开发",
  "salary_min":15000,
  "city":"北京",
  "company":{
    "name":"百度",
    "company_addr":"北京市软件园"
  },
  "publish_date":"2017-4-16",
  "comments":15
}


# 保存文档-不指定id
POST lagou/job/
{
  "title":"python django开发工程师",
  "salary_min":30000,
  "city":"上海",
  "company":{
    "name":"美团科技",
    "company_addr":"北京软件园A区"
  },
  "publish_date":"2017-4-16",
  "comments":20
}



# 获取文档
GET lagou/job/1


# 获取文档-指定字段
GET lagou/job/1?_source=title
GET lagou/job/1?_source=title,city


# 修改文档-覆盖修改
PUT lagou/job/1
{
  "title":"python分布式爬虫开发",
  "salary_min":15000,
  "company":{
    "name":"百度",
    "company_addr":"北京市软件园"
  },
  "publish_date":"2017-4-16",
  "comments":15
}

# 修改文档-更新方式
POST lagou/job/1/_update
{
  "doc": {
    "comments":36
  }
}



# 删除文档
DELETE lagou/job/1

# 删除索引
DELETE lagou

```



#### 8.3 elasticsearch批量操作

##### 8.3.1 批量获取

```python

# 1、批量获取
GET _mget
{
  "docs":[
    {
      "_index":"testdb",
      "_type":"job1",
      "_id":1
    },
    {
      "_index":"testdb",
      "_type":"job1",
      "_id":2
    } 
    ]
}


# 2、批量获取-索引相同
GET testdb/_mget
{
  "docs":[
    {
      "_type":"job1",
      "_id":1
    },
    {
      "_type":"job2",
      "_id":2
    } 
    ]
}


# 2、批量获取-索引、类型相同
GET testdb/job1/_mget
{
  "docs":[
    {
      "_id":1
    },
    {
      "_id":2
    } 
    ]
}

GET testdb/job1/_mget
{
  "ids":[1, 2]
}
```



##### 8.3.2 bulk批量操作

批量导入可以合并多个操作，比如index, delete, update,create等等，也可以帮助我们从一个索引导入到另一个索引

![elasticsearch05](C:\Users\Administrator\Desktop\简历\image\elasticsearch05.png)

```python
POST _bulk
{"index":{"_index":"lagou", "_type":"job", "_id":"1"}}
{"title":"python分布式爬虫开发","salary_min":15000,"city":"北京","company":{"name":"百度","company_addr":"北京市软件园"},"publish_date":"2017-4-16","comments":15}
{"index":{"_index":"lagou", "_type":"job2", "_id":"2"}}
{"title":"python django开发工程师","salary_min":30000,"city":"上海","company":{"name":"美团科技","company_addr":"北京软件园A区"},"publish_date":"2017-4-16","comments":20}
```



![elasticsearch06](C:\Users\Administrator\Desktop\简历\image\elasticsearch06.png)



#### 8.4 elasticsearch映射（mapping）

当我们创建索引的时候，可以预先定义字段的类型以及相关属性

![elasticsearch07](C:\Users\Administrator\Desktop\简历\image\elasticsearch07.png)

作用：会让索引建立的更加细致和完善

类型：静态映射和动态映射



|      内置类型       |                                           |
| :-----------------: | ----------------------------------------- |
|     string类型      | text、keywords                            |
|      数字类型       | long、integer、short、byte、double、float |
|      日期类型       | date【可以处理年月日时分秒】              |
|      bool类型       | boolean                                   |
|     binary类型      | binary                                    |
|      复杂类型       | object【字典中的字典】,  nested【列表】   |
| geo类型【地理位置】 | geo-point, geo-shape                      |
|      专业类型       | ip, competion                             |

![elasticsearch08](C:\Users\Administrator\Desktop\简历\image\elasticsearch08.png)

```python
# 一旦设置了索引的类型，不能修改
# 定义索引
PUT lagou
{
  "mappings": {
    "job":{
      "properties": {
        "title":{
          "type": "text"
        },
        "salary_min":{
          "type": "integer"
        },
        "city":{
          "type": "keyword"
        },
        "company":{
          "properties": {
            "name":{
              "type":"text"
            },
            "company_addr":{
              "type":"text"
            },
            "employee_count":{
              "type": "integer"
            }
          }
        },
        "publish_date":{
          "type": "date",
          "format": "yyyy-MM-dd"
        },
        "comments":{
          "type": "integer"
        }
      }
    }
  }
}


# 插入文档
POST lagou/job/2
{
  "title":"python分布式爬虫开发",
  "salary_min":15000,
  "city":"北京",
  "company":{
    "name":"百度",
    "company_addr":"北京市软件园",
    "employee_count":50
  },
  "publish_date":"2017-4-16",
  "comments":15
}


# 获取mapping
GET lagou/_mapping
GET lagou/_mapping/job
```



#### 8.5 elastisearch查询

查询分类：

基本查询：使用elasticsearch内置查询条件进行查询

组合查询：把多个查询组合在一起进行复合查询

过滤：查询同时，通过filter条件在不影响打分的情况下筛选数据



##### 8.5.1 基本查询

```python

#  制造数据
DELETE lagou

PUT lagou
{
  "mappings": {
    "job":{
      "properties": {
        "title":{
          "store": true, 
          "type": "text",
          "analyzer": "ik_max_word"
        },
        "company_name":{
          "store": true, 
          "type": "keyword"
        },
        "desc":{
          "type": "text"
        },
        "comments":{
          "type": "integer"
        },       
        "add_date":{
          "type": "date",
          "format": "yyyy-MM-dd"
        }
      }
    }
  }
}



POST lagou/job/
{
  "title":"python django 开发工程师",
  "company_name":"美团科技有限公司",
  "desc":"对django的概念熟悉，熟悉python基础知识",
  "comments":15,
  "add_time":"2017-4-1"
}


POST lagou/job/
{
  "title":"python scrapy redis分布式爬虫基础",
  "company_name":"百度科技有限公司",
  "desc":"对scrapy的概念熟悉，熟悉redis基础知识",
  "comments":5,
  "add_time":"2017-4-15"
}


POST lagou/job/
{
  "title":"elasticsearch打造搜索引擎",
  "company_name":"阿里巴巴科技有限公司",
  "desc":"熟悉数据结构算法，熟悉python基础知识",
  "comments":15,
  "add_time":"2017-6-28"
}

POST lagou/job/
{
  "title":"python打造推荐引擎系统",
  "company_name":"阿里巴巴科技有限公司",
  "desc":"熟悉推荐引擎的原理以及算法，掌握c语言",
  "comments":60,
  "add_time":"2016-10-20"
}



################################     开始查询   ####################################


# 1、match查询
# 分词器将词分开再逐个匹配
GET lagou/job/_search
{
  "query": {
    "match": {
      "title": "Python网站"
    }
  }
}

GET lagou/job/_search
{
  "query": {
    "match": {
      "title": "爬取"
    }
  }
}


# 2、term查询
# 与match的区别是term对获取的条件不做处理，仅仅原量查询
GET lagou/_search
{
  "query": {
    "term": {
      "title": "python"
    }
  }
}


# text类型与keywords类型的区别
# text会分词、keywords不会分词

# 能查询到数据
GET lagou/_search
{
  "query": {
    "term": {
      "title": "python" 
    }
  }
}


# 不能查询到数据
GET lagou/_search
{
  "query": {
    "term": {
      "company_name": "美团"
    }
  }
}



# 3、terms查询
# 多个词之间只要有一个匹配都会返回回来 
GET lagou/_search
{
  "query": {
    "terms": {
      "title": ["工程师","python", "系统"]
    }
  }
}



# 4、控制查询返回的数量 
# from 从第几个开始 
# size 返回数量 
GET lagou/job/_search
{
  "query": {
    "match": {
      "title": "python"
    }
  },
  "from": 0,  
  "size": 3
}


# 5、match_all查询 返回所有数据 
GET lagou/_search
{
  "query": {
    "match_all": {}
  }
}

# 6、match_phrase查询 
# 短语查询：会分词，满足所有的分词才匹配 
# slop 词与词之间的距离；如果词与词之间的距离小于 这个距离则匹配 ；否则不匹配
GET lagou/_search
{
  "query": {
    "match_phrase": {
      "title": {
        "query": "python系统",
        "slop":6
      }
    }
  }
}


# 7、multi_match查询 
# 可以指定多个字段进行查询匹配
# 比如查询title和desc这两个字段里面包含python的关键字词文档
# title^3 指定查询字段的权重
GET lagou/_search
{
  "query": {
    "multi_match":{
        "query": "python",
        "fields":["title^3", "desc"]
    }
  }
}


# 8、指定返回的字段
# "desc"没有返回的原因：desc的store为false
GET lagou/_search
{
  "stored_fields": ["title","company_name","desc"], 
  "query": {
    "match": {
      "title": "python"
    }
  }
}


# 9、通过sort把结果排序
GET lagou/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {
      "comments": {
        "order": "desc"
      }
    }
  ]
}


# 10、查询范围
# range查询 
# 10<=aaa<=20
GET lagou/_search
{
  "query": {
    "range": {
      "comments": {
        "gte": 10,
        "lte": 20,
        "boost": 2.0
      }
    }
  }
}


# 时间 
GET lagou/_search
{
  "query": {
    "range": {
      "add_time": {
        "gte": "2017-4-1",
        "lte": "now"
      }
    }
  }
}



# 11、wildcard查询[模糊查询]
GET lagou/_search
{
  "query": {
    "wildcard": {
      "title": {
        "value": "pyth*n",
        "boost": 2.0
      }
    }
  }
}


```



##### 8.5.1 联合查询

```python
# bool 查询
# bool 使用 must、should、must_not、filter来完成
# 如下：

# bool:{
#   "filter": [],
#   "must": [],  # 且 
#   "should": [], # 或者 
#   "must_not": {},
# }


# 建立测试数据
POST lagou/testjob/_bulk
{"index":{"_id":1}}
{"salary":10, "title":"Python"}
{"index":{"_id":2}}
{"salary":20, "title":"Scrapy"}
{"index":{"_id":3}}
{"salary":30, "title":"Django"}
{"index":{"_id":4}}
{"salary":30, "title":"Elasticsearch"}


# 1、简单的filter查询
# select * from testjob where salary=20
# 查询薪资为20k的工作
GET lagou/testjob/_search
{
  "query": {
    "bool": {
      "must": {
        "match_all":{}
      },
      "filter": {
        "term": {
          "salary": 20
        }
      }
    }
  }
}


# 2、也可指定多个值 

GET lagou/testjob/_search
{
  "query": {
    "bool": {
      "must": {
        "match_all":{}
      },
      "filter": {
        "terms": {
          "salary":[10, 20]
        }
      }
    }
  }
}



# select * from testjob where title="Python"
# 查询不到 term不做字段属性处理 
GET lagou/testjob/_search
{
  "query": {
    "bool": {
      "must": {
        "match_all":{}
      },
      "filter": {
        "term": {
          "title": "Python"
        }
      }
    }
  }
}




# 3、查看分析器解析的结果 
# ik_smart 分词器 
GET _analyze
{
  "analyzer": "ik_max_word",
  "text": "Python网络开发工程师 "
}



# 4、组合过滤查询 
# select * from testjob where (salary=20 or title=Python) and (salary != 30)

# 查询薪资等于20k或者工作为python的工作，排除工资为30k

GET lagou/testjob/_search
{
  "query": {
    "bool": {
      "should": [
        {"term": {"salary":20}},
        {"term": {"title":"python"}}
      ],
      "must_not": [
        {"term": {"salary":30}},
        {"term": {"salary":10}}
      ]
    }
  }
}



# 5、嵌套查询 

# select * from testjob where title="python" or (title="elasticsearch" and salary= 30)

GET lagou/testjob/_search
{
  "query": {
    "bool": {
      "should": [
        {"term": {"title":"python"}},
        {"bool": {
          "must": [
            {"term": {"title":"elasticsearch"}},
            {"term": {"salary":30}}
          ]
        }}
      ]
    }
  }
}



# 6、过滤空和非空
# 建立测试数据
POST lagou/testjob2/_bulk
{"index":{"_id":1}}
{"tags":["search"]}
{"index":{"_id":2}}
{"tags":["search","python"]}
{"index":{"_id":3}}
{"other_field":["some_data"]}
{"index":{"_id":4}}
{"tags":null}
{"index":{"_id":5}}
{"tags":["search", null]}


# 处理null空值的办法
# select * from testjob2 where tags is not null
GET lagou/testjob2/_search
{
  "query": {
    "bool": {
      "filter": {
        "exists": {
          "field": "tags"
        }
      }
    }
  }
}
```





#### 8.6 django+elasticsearch打造搜索系统-数据存储在elastisearch

原理：

1.在django中使用elasticsearch-dsl访问存储在elasticsearch中的爬虫数据，以json形式返回，再渲染到页面

2.用户的搜索记录可以使用cookie来保存； 爬虫的数量在爬取的时候每爬取一条就增加设置在redis中，然后再在django中获取该值渲染到页面中

3.热门搜索使用redis设置关键词加1:  redis_cli.zincrby("search_keywords_set", key_words)

```python
# 热门搜索前n个获取，以列表形式返回
topn_search = redis_cli.zrevrangebyscore("search_keywords_set", "+inf", "-inf", start=0, num=5)
```



django可视化scrapy

 https://github.com/holgerd77/django-dynamic-scraper 





#### 8.7 django+elasticsearch 全站搜索的实现思路

![1582313882216](C:\Users\Administrator\Desktop\简历\image\elasticsearch09.png)





### 9. docker常用命令

```python
1.镜像相关：

$ docker pull ubuntu:18.04   # 拉取镜像
$ docker images   # 列出镜像
$ docker rmi  镜像id/镜像:版本	#删除镜像
    
    
2.容器操作：【注：镜像名要放在参数后面】

$ docker run -it ubuntu:18.04 /bin/bash  # 交互式创建并启动一个容器，并进入该容器的 bash 终端，
$ docker run  -d -p 80:80 nginx # 创建并启动一个容器，-d后台运行， -p把本地端口映射到容器的端口中
    
$ docker exec -it 容器id  bash   # 进入后台运行的容器
$ docker exec -ti -u root 容器id bash # 以root用户进入
$ exit  # 退出进入的容器

$ docker ps # 列出正在运行的容器
$ docker ps -a  # 列出所有的容器【含停止的】

$ docker stop 容器id   # 停止容器
$ docker rm  容器id    # 删除容器
$ docker rm -f  容器id    # 强制删除容器，如果正在运行， 会发送 SIGKILL 信号给容器，进而删除


$ docker start 容器id   # 运行停止的容器
$ docker restart 容器id   # 重启容器

$ docker inspect 容器id  # 查看容器的配置，如ip


3. 其他
'''
容器配置文件出现问题无法启动：如不正确的修改mysql的配置文件，导致该容器无法启动
注意：如果停止容器后，再启动。启动不成功，说明容器中的配置文件有语法错误
- 怎么检查配置文件的语法错误？
      sudo docker logs 不能启动容器的id
      
- 怎么修改配置文件
  - 把容器中错误的配置文件，复制到宿主机
        sudo docker cp 容器名称:配置文件的位置 宿主机保存文件的位置
        
  - 复制完后，修改配置文件。然后在 复制回容器原来的位置
        sudo docker cp 宿主机保存文件的位置 容器名称:配置文件的位置
'''



```







### 10. devops方法论

#### DevOps是什么

DevOps是Development和Operations两个词的缩写

DevOps是一种方法或理念，它涵盖开发、测试、运维的整个过程。DevOps是提高软件开发、测试、运维、运营
等各部门的沟通与协作质量的方法和过程，DevOps强调软件开发人员与软件测试、软件运维、质量保障（QA）部门之间有效的沟通与协作，强调通过自动化的方法去管理软件变更、软件集成，使软件从构建到测试、发布更加快捷、可靠，最终按时交付软件。



#### DevOps如何落地

DevOps兴起于2009年，近年来由于云计算、互联网的发展，促进了DevOps的基础设施及工具链的发展，涌现了
一大批优秀的工具，这些工具包括开发、测试、运维的各各领域，例如：GitHub、Git/SVN、Docker、Jenkins、
Hudson、Ant/Maven/Gradle、Selenium、QUnit、JMeter等。下图是DevOps相关的工具集：

![1577288352951](C:\Users\Administrator\Desktop\简历\image\DevOps.png)





### 持续集成

#### 传统的软件开发流程如下：

1、项目经理分配模块给开发人员
2、每个模块的开发人员并行开发，并进行单元测试
3、开发完毕，将代码集成部署到测试服务器，测试人员进行测试。
4、测试人员发现bug，提交bug、开发人员修改bug
5、bug修改完毕再次集成、测试。



#### 问题描述：

1、模块之间依赖关系复杂，在集成时发现大量bug
2、测试人员等待测试时间过长
3、软件交付无法保障



#### 解决上述问题的思考：

1、能否把集成测试时间提前？
2、能否使用自动化工具代替人工集成部署的过程？



#### 持续集成

持续集成（Continuous integration）简称CI，持续集成的思想是每天要多次将代码合并到主干，并进行集成、测
试，这样就可以提早发现错误，进行修正。持久集成也属于DevOps
持续集成的好处：
1、自动化集成部署，提高了集成效率。
2、更快的修复问题。
3、更快的进行交付。
4、提高了产品质量。





![1577287693623](C:\Users\Administrator\Desktop\简历\image\CI.png)



```python
'''
1.把代码上传的github

2.在阿里云运行jenkins容器
$ docker exec -ti -u root 容器id bash  # 以root用户进入

下载python3.6： 步骤待研究
创建虚拟环境： virtualenv jenkinsenv -p /usr/bin/python3.6 --no-site-packages 

在jenkins配置【全局属性】：pip、python

'''


```



![1578750212938](C:\Users\Administrator\Desktop\简历\image\jenkinsenv.png)



```python
'''
3.在jenkins创建item
http://www.aqfofp.top:8080/
'''
```

定时轮询

![1578751326805](C:\Users\Administrator\Desktop\简历\image\jenkins01.png)





![1578751445263](C:\Users\Administrator\Desktop\简历\image\jenkins02.png)





### 11. Oauth2.0登录- 授权码授权模式 

![1584215280033](C:\Users\Administrator\Desktop\简历\image\0auth.png)



![1584215642088](C:\Users\Administrator\Desktop\简历\image\0auth1.png)

![1584216254342](C:\Users\Administrator\Desktop\简历\image\0auth2.png)





 在用户看来，整个过程只有两步，第一步是跳转到微博登录页，用户输入账号密码；

```html
<!--
先到http://open.weibo.com/微博开放平台，依次点击网站接入-立即接入（记得要先登录再点击，要不会没有反应），注册一个应用，获取app key和app secret
-->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<a href="https://api.weibo.com/oauth2/authorize?client_id=app_key&response_type=code&redirect_uri=http://127.0.0.1:8000/process">
    微博登录
</a>
</body>
</html>



当在微博登录页登录成功后，会以redirect_uri?code=xxxx（本例子中为

http://127.0.0.1:8000/process?code=xxxxx
）的方式回调你所填的uri，这时就可以获取到授权码code了，需要注意的是，回调的redirect_uri需要在 我的应用-应用信息-高级信息-OAuth2.0 授权设置中进行设置，要不回调时会报错
```





#### 11.2 获取acess_token

acess_token不仅仅可以用来获取微博的用户信息，还可以调用微博提供的其他api，详情可以看官方文档http://open.weibo.com/wiki/。首先看获取token的代码：

```python
def get_token(code):
    """
    获取access_token
    http://open.weibo.com/wiki/Oauth2/access_token
    """
    app_key = app_key
    app_secret = app_secret
    token_url = "https://api.weibo.com/oauth2/access_token"
    params = {
        "client_id": app_key,
        "client_secret": app_secret,
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": "http://127.0.0.1:8000/process"
    }
    result = requests.post(url=token_url, data=params)
    return result
```



 主要看params中的参数，这些都是获取access_token的必须参数，code为步骤1中获取到的授权码，grant_type在授权码模式中就是这个固定值 

```python
{'access_token': 'xxxxxxxxxx', 'remind_in': '157679999', 
 'expires_in': 157679999, 'uid': '392039283', 'isRealName': True}

# uid是登录微博用户的id，可以通过这个获取用户信息，
```



#### 11.3 获取用户信息

```python
def get_user_info(result):
    """
    获取用户信息
    """
    get_user_url = "https://api.weibo.com/2/users/show.json"
    uid = result["uid"]
    access_token = result["access_token"]
    user_info = requests.get(url=get_user_url, params={"access_token": access_token, "uid": uid})
    return user_info
```



#### 11.4 实现本地登录

```python
def process(request):
    code = request.GET.get("code")
    result = get_token(code)  # 获取access_token和用户uid
    result = result.json()  # 将json格式字符串转化为字典对象

    user_info = get_user_info(result).json()
	# 接下来是你的网站的登录处理，你有两种选择：
    #   1、你可以不做任何处理，只要用户成功登录了微博，就直接跳转到你的网站首页。
    #   2、你可以对比本地数据库，看是否存在该用户，如果存在则直接跳转，
    #	  不存在可以提示用户绑定你的网站的账号，或者直接用
    #       微博用户信息作为该用户在你本地的账号
    return redirect("/index")
```



 这是一个视图函数，是处理步骤1中http://127.0.0.1:8000/process，这个回调uri的，可以看到我们获取了授权码code，然后获取access_token和uid（步骤2），接着获取用户信息（步骤3），接下来的验证要根据自己的实际情况进行。最后所有东西处理完毕后，重定向到首页index去。 



#### 11.5 路由

```python
from django.conf.urls import url
from django.contrib import admin
from  django_app import views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^login/', views.login),
    url(r'^process/', views.process),
    url(r'^index/', views.index),
]
```





### 12 再述scrapy



![1582394422097](C:\Users\Administrator\Desktop\简历\image\scrapy01.png)

```python
'''
1. scheduler调度器里面存放的不是url地址，而是Requests对象，Requests相当于我们定义的一个类，在Requests可能有一些属性，比如url地址、header、post数据、代理等等

2.在Response返回到Spider提取内容以及提取url，url地址先要组装成Requests对象，再发送到 scheduler调度器

'''

xmlynew/scrapy.cfg  
配置文件:
    1.指定项目的配置文件在xmlynew.settings
    2.[deploy]可以通过scrapyd帮助我们将代码发布到服务器上
    
    
log等级：debug、info、warning、error    
LOG_LEVEL = 'WARNING'  # 比warning小的日志等级都不会显示

response.xpath()  # 返回 以Selector对象组成的列表

li.xpath().extract_first()  # extract_first获取不到返回None


def parse() 
# 为什么使用parse方法呢？
# 父类Spider要求必须实现该方法，同时可以让引擎调用
def parse(self, response):
        raise NotImplementedError('{}.parse callback is not defined'.format(self.__class__.__name__))


def parse():
    yield item   
# 使用yield 使该函数变为生成器、我们的引擎会遍历该生成器，每遍历一次会获取一个结果，而且可以减少内存的占用
# spider只能返回：Request、BaseItem、dict或None


class XmlynewPipeline(object):
    def process_item(self, item, spider):
        return item
    
# 为什么该函数要return item    
# 该函数是由引擎判断如果spider返回的是item,就会调用该函数，但是项目中可能存在多个Pipeline，
# 而Pipeline是一个一个执行process_item的，那么就需要上一个Pipeline的process_item返回item，
# 然后下面的Pipeline才能获取item的内容，如果process_item没有返回值，则默认函数返回值为None


# 第二个参数spider就是我们定义的XmlynewspiderSpider类
# 可以通过spider.name获取相关的类属性
# 也可以spider.name == ‘xx’ 判断不同的爬虫
```



![1582572816893](C:\Users\Administrator\Desktop\简历\image\scrapy02.png)

#### 12.1日志模块使用

```python
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(filename)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

logger.debug("Do something 调试信息")   # 调试信息
logger.info("Start print log 普通信息")  # 普通信息
logger.warning("Something maybe 警告")  # 警告
logger.error("error 错误")  # 错误信息
logger.critical("critical 致命错误")  # 致命错误


'''
logging.basicConfig函数各参数：
filename：指定日志文件名；
filemode：和file函数意义相同，指定日志文件的打开模式，'w'或者'a'；
format：指定输出的格式和内容，format可以输出很多有用的信息
datefmt：指定时间格式，同time.strftime()；
level：设置日志级别，默认为logging.WARNNING；

format参数：作用
 
%(levelno)s：打印日志级别的数值
%(levelname)s：打印日志级别的名称
%(pathname)s：打印当前执行程序的路径，其实就是sys.argv[0]
%(filename)s：打印当前执行程序名
%(funcName)s：打印日志的当前函数
%(lineno)d：打印日志的当前行号
%(asctime)s：打印日志的时间
%(thread)d：打印线程ID
%(threadName)s：打印线程名称
%(process)d：打印进程ID
%(message)s：打印日志信息
'''





#　日志写文件
def log2():
    logger = logging.getLogger(__name__)
    logger.setLevel(level=logging.INFO)
    
    # 1.创建一个FileHandler对象
    filehandler = logging.FileHandler("log.txt", encoding="utf-8", mode="a") 
    
    # 2. 设置输出日志格式
    formatter = logging.Formatter('%(asctime)s - %(filename)s - %(levelname)s - %(message)s')
    filehandler.setFormatter(formatter)   
    
    # 将filehandler添加到logger
    logger.addHandler(filehandler)  

    logger.debug("Do something 调试信息")   # 调试信息
    logger.info("Start print log 普通信息")  # 普通信息
    logger.warning("Something maybe 警告")  # 警告
    logger.error("error 错误")  # 错误信息
    logger.critical("critical 致命错误")  # 致命错误


if __name__ == '__main__':
    log2()
    
    
    
Django 中的日志配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    # 格式配置
    'formatters': {
        'simple': {
            'format': '%(asctime)s %(module)s.%(funcName)s: %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S',
        },
        'verbose': {
            'format': ('%(asctime)s %(levelname)s [%(process)d-%(threadName)s] '
                    '%(module)s.%(funcName)s line %(lineno)d: %(message)s'),
            'datefmt': '%Y-%m-%d %H:%M:%S',
        }
    },
    # Handler 配置
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'DEBUG' if DEBUG else 'WARNING'
        },
        'info': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': f'{BASE_DIR}/logs/info.log',  # 日志保存路径
            'when': 'D',        # 每天切割日志
            'backupCount': 30,  # 日志保留 30 天
            'formatter': 'simple',
            'level': 'INFO',
        },
        'error': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': f'{BASE_DIR}/logs/error.log',  # 日志保存路径
            'when': 'W0',      # 每周一切割日志
            'backupCount': 4,  # 日志保留 4 周
            'formatter': 'verbose',
            'level': 'WARNING',
        }
    },
    # Logger 配置
    'loggers': {
        'django': {
            'handlers': ['console'],
        },
        'inf': {
            'handlers': ['info'],
            'propagate': True,
            'level': 'INFO',
        },
        'err': {
            'handlers': ['error'],
            'propagate': True,
            'level': 'WARNING',
        }
    }
}



使用

import logging
inf_log = logging.getLogger('inf')
```



### 13、Python基础

```python
'''
一、闭包、装饰器

闭包的作用：闭包可以保存外部函数内的变量，不会随着外部函数调用完而销毁。
注意点：由于闭包引用了外部函数的变量，则外部函数的变量没有及时释放，消耗内存。
'''

闭包：

# 定义一个外部函数
def func_out(num1):
    # 定义一个内部函数
    def func_inner(num2):
        # 内部函数使用了外部函数的变量(num1)
        result = num1 + num2
        print("结果是:", result)
    # 外部函数返回了内部函数，这里返回的内部函数就是闭包
    return func_inner

# 创建闭包实例    
f = func_out(1)  # func_out已经结束，但其变量num1还占有空间
# 执行闭包
f(2)
f(3)

装饰器：
在不改变原函数的代码下，给原函数增加额外功能的函数，它本质上就是一个闭包函数
# 添加一个登录验证的功能
def check(fn):
    def inner():
        print("请先登录....")
        fn()
    return inner


def comment():
    print("发表评论")

# 使用装饰器来装饰函数
comment = check(comment)
comment()


# 使用语法糖方式来装饰函数
@check
def comment():
    print("发表评论")






'''

二、面向对象的多态
'''
'''
在python中不存在真正的多态，因为python是一个动态数据类型的语言。
鸭子模型：如果有一只鸟，走路像鸭子，叫声像鸭子，那么我们就称这只鸟叫鸭子。
我们不关心它的数据类型，我们只关系它的使用。

isinstance(obj,type)
功能：判断某个对象是否属于某种类型。
当这个对象属于这种类型或者属于这种类型的子类，那么返回True，否则返回False。

dir(obj)
功能：查看指定对象的所有的属性以及方法，以列表的方式返回。
'''


class Animal():
    def __init__(self,name):
        self.name = name

    @staticmethod
    def run(ani):
        print("%s跑..."%ani.name)


class Cat(Animal):
    pass


class Dog(Animal):
    pass


class Person():
    def __init__(self,name):
        self.name = name


if __name__ == '__main__':
    cat = Cat("Tom")
    Animal.run(cat)  # Tom跑...
    dog = Dog("jerry")
    Animal.run(dog)  # jerry跑...
    per = Person("小明")
    Animal.run(per)  # 小明跑...
    print(isinstance(dog,Dog))  # True
    print(isinstance(dog,Animal))  # True
    print(isinstance(per,Animal))  # False
    print(isinstance(per,(Animal,Person)))  # True
    print(dir(cat))

  


'''
对比java的多态
'''

class Animal {
    public void eat(){
        System.out.println("animal eatting...");
    }
}
 
class Cat extends Animal{
 
    public void eat(){
 
        System.out.println("我吃鱼");
    }
}
 
class Dog extends Animal{
 
    public void eat(){
 
        System.out.println("我吃骨头");
    }
 
    public void run(){
        System.out.println("我会跑");
    }
}


class Apple{
	  
	public void eat(){
 
        System.out.println("我吃肥料");
    }
	
}
 
public class Main {
 
    public static void main(String[] args) {
 
        Animal animal = new Cat();  //向上转型  一种事物的多种形态
        animal.eat();
 
        animal = new Dog();
        animal.eat();
		
		animal = new Apple();  #此次报错 不能转型， 因为Apple不是继承自 Animal
		animal.eat();
    }
 
}

'''
我吃鱼
我吃骨头

'''
多态依赖于继承，然而对于python来说是弱语言类型，那么它的变量可以赋值给任何类型，所以不存在多态







'''
三、可迭代对象、迭代器、生成器区别与联系
'''
# 1.可迭代对象
'''
特点：
1.可以使用for循环遍历
2.可迭代的类型实现了
def __iter__()  方法

3.常见的可迭代对象：list、tuple、dict、set
'''
from collections import Iterable, Iterator, Generator


def my_iterable():
    return list(range(10))



# 2.迭代器
'''
特点：
1.可以使用for循环遍历以及next()方法获取
2.可迭代的类型实现了
def __iter__() 和 def __next__()方法

3.可以使用iter()将可迭代对象list、tuple、dict、set转换为迭代器
4.构建迭代器的时候，不像列表把所有元素一次性加载到内存，而是以一种延迟计算（lazy evaluation）方式返回元素
好处：减少内存的开销
'''


def my_iter():
    return iter(list(range(8000)))



# 3.生成器
'''
特点：
1.生成器自动实现了“迭代器协议”（即__iter__和next方法）
2.生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样
'''
def my_gen():
    for i in range(8000):
        yield i


if __name__ == '__main__':
    print(isinstance(my_iterable(), Iterable))  # true
    print(isinstance(my_iter(), Iterator)) # true
    print(isinstance(my_gen(), Generator)) # true

    print(my_iterable()) # []
    print(my_iter())  # list_iterator object
    print(my_gen())  # generator object
    
    
yield from 的作用（后加可迭代对象）
1. 链接子生成器，顾名思义：将可迭代对象一个一个的yield出来
2. 作为调用者和子生成器的通道   
```

```python
import asyncio
import time

'''
协程完整的工作流程是这样的

    1.定义/创建协程对象
    2.定义事件循环对象容器
    3.将协程转为task任务
    4.将task任务扔进事件循环对象中触发

基本概念：

    1、event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数（协程）注册到事件循环上。
    当满足事件发生的时候，调用相应的协程函数。

    2、coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，
    而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。

    3、future 对象： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别

    4、task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，
    其中包含任务的各种状态。Task 对象是 Future 的子类，
    它将 coroutine 和 Future 联系在一起，将 coroutine 封装成一个 Future 对象


总结：使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，
函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，
再进行下一个协程的执行，协程的目的也是让一些耗时的操作异步化
asyncio.sleep(n)，是asyncio自带的工具函数，他可以模拟IO阻塞，他返回的是一个协程对象。
   
'''


async def hello(name):

    await asyncio.sleep(10)
    temp = 'Hello ' + name
    return temp


async def hello2(name):
    # time.sleep(1)
    await asyncio.sleep(1)
    temp = 'Hello ' + name
    return temp


def callback(future):
    print('这里是回调函数，获取返回结果是：', future.result())


if __name__ == '__main__':
    # 定义协程对象
    coroutine = hello("World")
    coroutine2 = hello2("kit")

    loop = asyncio.get_event_loop()  # 定义事件循环对象容器

    task = loop.create_task(coroutine)  # 将协程转为task任务
    task2 = asyncio.ensure_future(coroutine2)  # 将协程转为task任务

    task.add_done_callback(callback)  # 绑定回调函数
    task2.add_done_callback(callback)

    loop.run_until_complete(task)  # 将task任务扔进事件循环对象中并触发
    loop.run_until_complete(task2)  # 将task任务扔进事件循环对象中并触发

    print(task.result())
    print(task2.result())
```



```python
'''
四、网络编程、进程、线程、协程
'''

服务器端：
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(("127.0.0.1", 9090))
sock.listen(6)
clientSocket, clientAddress = sock.accept()
while True:
    data = clientSocket.recv(1024)
    print("客户端说：" + data.decode("utf-8"))
    sendData = input("输入返回给客户端的数据(退出输入：q):")
    if sendData == 'q':
        break
    clientSocket.send(sendData.encode("utf-8"))  # 返回值为发送成功的字节数

clientSocket.close()  # 关闭连接

客户端：
import socket
client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("127.0.0.1", 9090))
while True:
    data = input("请输入给服务器发送的数据:")
    client.send(data.encode("utf-8"))

    # 等待接收数据
    info = client.recv(1024)
    print("服务器说：", info.decode("utf-8"))





'''
五、单元测试
'''
import unittest


def add(a, b):
    if isinstance(a, str) and isinstance(b, str):
        return a + '+' + b
    elif isinstance(a, list) and isinstance(b, list):
        return a + b
    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):
        if a == 3:
            print(a)
        return a + b
    else:
        return None


class Test_Add(unittest.TestCase):

    def setUp(self):
        pass

    def test_add_case1(self):
        a = 'hello'
        b = 'world'
        res = add(a, b)
        self.assertEqual(res, 'hello+world')

    def test_add_case2(self):
        a = 1
        b = 2
        res = add(a, b)
        self.assertEqual(res, 4)

    def test_add_case3(self):
        a = [1, 2]
        b = [3]
        res = add(a, b)
        self.assertEqual(res, [1, 2, 3])

    def test_add_case4(self):
        a = 2
        b = "3"
        res = add(a, b)
        self.assertEqual(res, None)


if __name__ == '__main__':
    # suite = unittest.TestSuite()
    # suite.addTest(Test_Add('test_add_case1'))
    # suite.addTest(Test_Add('test_add_case2'))
    # suite.addTest(Test_Add('test_add_case3'))
    # suite.addTest(Test_Add('test_add_case4'))
    # run = unittest.TextTestRunner()
    # run.run(suite)

    # 上面操作时：建立测试套=>将测试用例加入测试套中=>运行测试套

    unittest.main()  # 一个操作完成上述过程
    
    
# 1.在命令行运行
> python 测试文件.py


# 使用coverage包可以运行测试用例可以查看测试覆盖率
>coverage run test_func_add.py    # 生成测试结果文件.coverage
>coverage html




'''
mock测试
'''
from unittest import mock
import unittest

class Operator():

    def multipy(self, a, b):
        pass


# test Operator class
class TestCount(unittest.TestCase):

    def test_add(self):
        op = Operator()

        op.multipy = mock.Mock(return_value=15, )  # 利用Mock类，我们假设返回的结果为15
        # op.multipy = mock.Mock(return_value=15, side_effect=op.multipy)

        # 调用multipy函数，输入参数为4,5,实际并未调用
        result = op.multipy(4, 5)

        # 声明返回结果是否为15
        self.assertEqual(result, 15)


if __name__ == '__main__':
    '''
    通过Mock类，我们即使在multipy函数并未实现的情况下，仍然能够通过想象函数执行的结果来进行测试，
    这样如果有后续的函数依赖multipy函数，也并不影响后续代码的测试
    '''
    unittest.main()



    # op = Operator()
    # # 利用Mock类，我们假设返回的结果为15
    # op.multipy = mock.Mock(return_value=15)
    # print(op.multipy(4, 5))  # 15
```



### 14 项目开发经典



![14-2](C:\Users\Administrator\Desktop\简历\image\14-2.png)



```python
'''
软件开发流程：
1.需求分析:
产品向客户了解需求，定好大致功能模块=>深入了解和分析需求,输出相关的需求规格书=>与客户确认需求、需求评审

2.概要设计：
开发者进行系统设计（概要设计）=>
包括系统的基本处理流程、系统的组织结构、模块划分、功能分配、接口设计、运行设计、数据结构设计和出错处理设计

3.详细设计：
开发者进行详细设计=>
包括实现具体模块所涉及到的主要算法、数据结构、类的层次结构及调用关系，软件系统各个层次中的每一个程序(每个模块或子程序)的设计考虑=>输出【软件系统详细设计报告】


4.编码
开发者根据《软件系统详细设计报告》中对数据结构、算法分析和模块实现等方面的设计要求，开始具体的编写程序工作，分别实现各模块的功能，从而实现对目标系统的功能、性能、接口、界面等方面的要求

5.测试

6.软件交付、验收、维护
'''
```







![1584217059124](C:\Users\Administrator\Desktop\简历\image\14-1.png)

```python
'''
# 1.技术栈：
# http://naotu.baidu.com/file/87ab219634ed578b7b834199717c25f1?token=191e6d522e0b40ba
'''


#1、使用pipenv创建虚拟环境

'''
当你的应用程序使用的两个库有冲突的依赖关系时，你的情况会变得很艰难。Pipenv 希望通过在一个名为 Pipfile.lock 的文件中跟踪应用程序相互依赖关系树来减轻这种痛苦。Pipfile.lock 还会验证生产中是否使用了正确版本的依赖关系
'''
> pip3 install pipenv
> ln -s /usr/local/python3/bin/pipenv /usr/bin/pipenv

> mkdir myproject
> cd myproject
> pipenv --python 3.7   # 创建虚拟环境,将当前目录与虚拟环境绑定

# 安装包（进入绑定的目录，pipfile可以修改安装包的源）
> pipenv install requests --skip-lock  # 跳过日志输出
> pipenv graph  # 查看包的依赖关系
> pipenv shell  # 进入虚拟环境,退出exit
> pipenv install --dev pytest --skip-lock # 在开发环境安装包
> pipenv --where  # 定位项目路径
> pipenv --venv   # 定位虚拟环境路径
> pipenv --py   # 定位python解析器的路径
> pipenv check   # 检查包的安全漏洞
> pipenv --rm   # 删除虚拟环境
> pipenv run python3 manage.py makemigration  # 运行Python命名


# 2、使用cookiecutter搭建项目框架
> pip3 install cookiecutter
> /usr/local/python3/bin/cookiecutter https://github.com/pydanny/cookiecutter-django.git
    
> yum -y install tree


# mysql 
>create database zanhu charset=utf8;
>create database test_zanhu charset=utf8;
>create user 'zanhu'@'%' identified by 'zanhu';
>grant all on zanhu.* to 'zanhu'@'%';
>grant all on test_zanhu.* to 'zanhu'@'%';
>flush privileges;


# 
# 1.配置本地路径到远程路径的映射 Tools->deployments->configuration
# 2.连接远程python解析器 file->settings -> python interpreter
# 3.配置django server  【edit configuration】、file->settings ->【django】 support


# 三、单元测试用例最佳实践：
1、理论上视图、路由、模型类、表单都要测试，为每一个类中的方法都要编写测试用例
2、编写的测试用例功能要最小化，获取文章是否返回200状态码，文章不存在是否返回404状态码
3、编写的测试用例尽可能简单，如果要测试的函数比较复杂，那么你要写多个测试用例来测试该函数
4、将代码提交到master分支或者push的时候一定要跑一下本项目的所有测试用例

测试覆盖度报告：django使用converage包，使用converage运行项目的所有测试用例

对于模型的测试用例：
1.模型的增删改查（有关联关系的）、模型中的方法

对于路由的测试用例：
1.正向解析与反向解析

对于视图函数、类视图测试用例：




from django.urls import reverse, resolve
from django.test import TestCase


class TestArticleurl(TestCase):

    def setUp(self):
        pass

    def test_detail_reverse(self):
        self.assertEqual('/index/1', reverse('weblog:index', args=(1,)))

    # def test_detail_resolve(self):
    #     self.assertEqual('weblog:index', resolve('/index/1'))

    def tearDown(self):
        pass
    

    
# 测试模型的方法    
from django.test import TestCase
from myauth.models import User_evaluation


# Create your tests here.
class ModelTest(TestCase):
    def setUp(self):
        User_evaluation.objects.create(user_id=16, movie_id=1, score=8.8)

    def test_evaluation_model(self):
        scorce = User_evaluation.objects.get(user_id=16, movie_id=1)
        self.assertEqual(scorce.score, 8.8)

    def tearDown(self):
        pass  
    
    
# python manage.py test  测试全部用例
# python manage.py test appname  测试某个APP
# python manage.py test alarm.tests.ModelTestCase  测试某个app下的TeseCase类

# 生成测试报告
coverage run --source='.' manage.py test
coverage report -m
```



### 15、HTTPS概述

![1584868838680](C:\Users\Administrator\Desktop\简历\image\https.png)

```python
'''
HTTPS是如何加密数据的

对称加密:加密数据用的密钥，跟解密数据用的密钥是一样的
对称加密的优点在于加密、解密效率通常比较高。缺点在于，数据发送方、数据接收方需要协商、共享同一把密钥，并确保密钥不泄露给其他人


非对称加密: 加密数据用的密钥（公钥），跟解密数据用的密钥（私钥）是不一样的
公钥: 其实就是字面上的意思——公开的密钥，谁都可以查到。因此非对称加密也叫做公开密钥加密
私钥： 就是非公开的密钥，一般是由网站的管理员持有

公钥、私钥两个有什么联系呢：
简单的说就是，通过公钥加密的数据，只能通过私钥解开。通过私钥加密的数据，只能通过公钥解开

'''


'''
问题一：公钥如何获取
证书：可以暂时把它理解为网站的身份证。这个身份证里包含了很多信息，其中就包含了上面提到的公钥
CA（证书颁发机构）
强调两点：
可以颁发证书的CA有很多（国内外都有）。
只有少数CA被认为是权威、公正的，这些CA颁发的证书，浏览器才认为是信得过的。

网站向CA提交了申请，CA审核通过后，将证书颁发给网站，用户访问网站的时候，网站将证书给到用户


问题二：数据传输仅单向安全
即通过私钥加密的数据，可以用公钥解密还原
HTTPS虽然用到了公开密钥加密，但同时也结合了其他手段，如对称加密，来确保授权、加密传输的效率、安全性

'''

'''
概括来说，整个简化的加密通信的流程就是：

小明访问XX，XX将自己的证书给到小明（其实是给到浏览器，小明不会有感知）
浏览器从证书中拿到XX的公钥A
浏览器生成一个只有自己知道的对称密钥B，用公钥A加密，并传给XX（其实是有协商的过程，这里为了便于理解先简化）
XX通过私钥解密，拿到对称密钥B
浏览器、XX 之后的数据通信，都用密钥B进行加密
'''

```

### 16 http

```python
'''
1.请求头：request header  =>User-agent、Acceptd、Referer、cookie
2.请求方法：request method => get、post、delete、put
3.请求参数：

1.响应头：response header
2.响应状态码：response status
3.响应内容：


HTTP的请求与响应流程：
1.客户端通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接到Web服务器
2.通过TCP套接字，客户端向Web服务器发送一个文本的HTTP请求报文
3.Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取
4.释放连接TCP连接
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;
若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
因为keepalive在很多情况下能够重用连接，减少资源消耗，缩短响应时间

5.客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML

'''
```



### 17 crm知识点



#### 17.1 权限系统

```python
'''
1.权限系统的流程：
首先，设置访问白名单列表,如用户登陆uri,当用户登陆时,在中间件process_request校验path_info是否在白名单中，登陆成功后通过用户获取对应的角色信息放入请求对象request中，以及通过默认的角色获取对应的权限列表及菜单列表【构造父子结构】，并保存到session中,最后访问相关的url时，再在中间件中做权限校验

2.为什么要把权限放入session？
减少数据库的查询操作，因为每次访问一个url都要比较看是否在权限列表中

3.权限系统的表有几个？
1）用户表、
2）角色表、
3）用户与角色关系表（多对多的关系，一个用户可以有多个角色，一个角色可以有多个用户）、
4）角色与权限关系表（多对多的关系，一个角色用户可以有多个权限，一个权限可以分配给多个角色）、
5）权限表
6）菜单表
7）权限与菜单关系表
（多对一的关系，一个大菜单可以有多个可以作为菜单的权限【即二级菜单】，一个权限可以设置为null则不是菜单【如增加、删除权限/按钮】，不为null时则是一个可以设置为二级菜单的权限只能对应一个大菜单）


4.权限表有哪些必要字段
    title、url、
    name（'URL别名'）、
    menu、
    pid（'对于非菜单权限需要选择一个可以成为菜单的权限，用户做默认展开和选中菜单'）
    
    
5.动态“二级”菜单、默认展开非菜单URL、访问路径导航【面包屑导航】 ==> 使用templatetags



6.粗粒度到按钮


9.角色管理、用户管理

10.菜单管理
【一级菜单（列表、增加、删除、修改）、
  二级菜单（列表、增加、删除、修改）、
  菜单下的权限（列表、增加、删除、修改）、批量权限表单处理（获取当前项目中所有的URL）】
  
1）首先获取一级菜单，然后在前台进行展示，一级菜单的列表、增加、删除、修改使用一个modeform完成
如果点击选择了一个一级菜单，传给后台该一级菜单id，然后获取能成为菜单的权限信息，并在前端显示，
二级的列表、增加、删除、修改也使用一个modeform完成，
同样点击选择了一个二级菜单，传给后台该二级菜单id，然后获取该菜单下的权限信息，并在前端显示，
权限信息的列表、增加、删除、修改也使用一个modeform完成，


2）权限批量操作处理（获取当前项目中所有的URL）
	1、权限为啥要用批量操作？：
	程序是新建的，有很多模块功能，那么就会有很多相应的url，不可能一个一个增加到权限表中？
	后期其他程序员变更url，那么需要一个个去比对进行修改
	
	2、如何自动的获取系统的url及与权限表的url的差异（系统路由修改删除要自动检测、权限表误删除要自动发现与当前系统路由差异）？
	
	
	递归的方式获取系统的url，生成以{namespace:name:url}形式
	orm获取权限表的url
	
	存在系统路由集合及权限表集合的数据集：求需要新建的权限、需要删除的权限、需要更新的权限
	
	需要新建的权限（初始值）：系统路由集合 - 权限表集合
	需要删除的权限（初始值）：权限表集合 - 系统路由集合
	需要更新的权限（初始值）：权限表集合 & 系统路由集合
	
	
Django针对不同的formset提供了3种方法: formset_factory, modelformset_factory和inlineformset_factory

11.权限分配如何做？
1、如果是get的方式时,获取所有用户信息、所有角色信息、以及三级菜单信息，都是以字典的形式，然后在页面展示三者的信息

2、
当点击选择用户时，传给后台用户id，获取当前用户拥有的角色信息，并更新当前页面的角色信息栏的选择框状态
变更角色时【点击角色面板的保存】更新用户角色信息中间表


当点击选择角色时,传给后台角色id，获取当前角色拥有的权限信息，并更新当前页面的角色信息栏的选择框状态
变更角色的权限时【点击权限面板的保存】更新角色权限信息中间表

'''
```



#### 17.2 modelform的使用

```python
1、业务模型的列表、增加、修改
2、局部钩子函数、全局钩子函数
3、验证通过方法is_valid()


form和modelform的区别：
1.生成HTML标签   
==> form要自己定义字段、modelform指定模型及过滤字段
都可以生成HTML标签
class MyForm(Form):
    user = fields.CharField(
        widget=widgets.TextInput(attrs={'id': 'i1', 'class': 'c1'})
    )

class PermissionModelForm(forms.ModelForm):
    class Meta:
        model = models.Permission
        fields = ['title', 'name', 'url']

2.验证用户数据（显示错误信息） 
==>form要在自己定义字段属性里增加字段校验、modelform根据模型生成对应的校验也可单独增加
都有局部钩子函数、全局钩子函数进行自定义校验


3.初始化页面显示内容
==> form、modelform都可以初始化字段初始值
def index(request):
    if request.method == "GET":
        values = {'user': 'root', 'city': 2}
        obj = MyForm(values)
        

def permission_edit(request, pk):
    permission_object = models.Permission.objects.filter(id=pk).first()

    if request.method == 'GET':
        form = PermissionModelForm(instance=permission_object)        

```



#### 17.3 templatetags模板标签的三种使用

```python
'''
1.@register.simple_tag
为什么只能是register，因为Django源码里就是这么解析的
'''
from django import template
register = template.Library()  # 注意，这里的变量名一定是register,可不是任意的名称

@ register.simple_tag
def hello(*args):
    return "hello " + " ".join(str(args))

然后就可以在模板中需要使用tag的页面引用自定义tag了
index.html

{% load hellotag %}
{% hello "world !" %}


'''
2.@register.inclusion_tag()
主要作用：通过渲染一个模板来显示一些数据
将menu_list传个一个模板，然后在模板中显示数据，
那么引用这个标签multi_menu时，就会返回一个已经渲染好的含html标签的块
'''
# rbac.py

from django.template import Library
register = Library()

@register.inclusion_tag('rbac/multi_menu.html')
def multi_menu(request):
    """
    创建二级菜单
    :return:
    """
    menu_dict = request.session[settings.MENU_SESSION_KEY]
    key_list = sorted(menu_dict)  # 对字典的key进行排序
    ordered_dict = OrderedDict()  # 空的有序字典

    for key in key_list:
        val = menu_dict[key]
        val['class'] = 'hide'
        for per in val['children']:
            if per['id'] == request.current_selected_permission:
                per['class'] = 'active'
                val['class'] = ''
        ordered_dict[key] = val
    return {'menu_dict': ordered_dict}


# multi_menu.html
<div class="multi-menu">
    {% for item in menu_dict.values %}
        <div class="item">
            <div class="title"><span class="icon-wrap"><i class="fa {{ item.icon }}"></i></span> {{ item.title }}</div>
            <div class="body {{ item.class }}">
                {% for per in item.children %}
                    <a class="{{ per.class }}" href="{{ per.url }}">{{ per.title }}</a>
                {% endfor %}
            </div>

        </div>
    {% endfor %}
</div>


# 引用multi_menu request
# layout.html
<div class="pg-body">
    <div class="left-menu">
        <div class="menu-body">
            {% multi_menu request %}
        </div>
    </div>
    <div class="right-body">
        {% breadcrumb request %}
        {% block content %} {% endblock %}
    </div>
</div>



'''

3.@register.filter
自定义过滤器filter
粗粒度控制到按钮
'''

先看自带的过滤器：

1  add ：   给变量加上相应的值
#value=5
{{ value|add:3 }}<br>    # 相当于5+3，add()需要两个参数，第一个参数为|之前的，后面需要再加一个

2.upper ：全变为大小
#value1="aBcDe"
{{ value1|upper }}<br>  # upper只有一个参数


# 自定义过滤器

# rbac.py
from django import template
from django.utils.safestring import mark_safe

register = template.Library()   #register的名字是固定的,不可改变
@register.filter
def has_permission(request, name):
    """
    判断是否有权限
    :param request:
    :param name:
    :return:
    """
    if name in request.session[settings.PERMISSION_SESSION_KEY]:
        return True
    
    
# customer.html  ==>粗粒度控制到按钮
<div class="btn-group" style="margin: 5px 0">
{% if request|has_permission:"web:customer_add" %}  # 判断请求对象是否有增加的权限
<a class="btn btn-default" href="{% url 'web:customer_add' %}">
<i class="fa fa-plus-square" aria-hidden="true"></i> 添加客户
</a>
{% endif %}

{% if request|has_permission:"web:customer_import" %}
<a class="btn btn-default" href="{% url 'web:customer_import' %}">
<i class="fa fa-file-excel-o" aria-hidden="true"></i> 批量导入
</a>
{% endif %}

</div>
```



#### 17.4 构造父子结构与家族结构

```python
父子结构
1. 构造权限结构

		def role_test(request):
			# 问题：从数据库中获取所有的权限
			"""
			{
				1:{
					'title':'账单列表',
					'url':'/payment/list/',
					'name':'payment_list',
					children:[
						{'title':'删除账单','url':'/payment/list/','name':'payment_list'},
						{'title':'编辑账单','url':'/payment/list/','name':'payment_list'},
						{'title':'添加账单','url':'/payment/list/','name':'payment_list'},
					]
				},
				 2:{
					'title':'客户列表',
					'url':'/payment/list/',
					'name':'payment_list',
					children:[
						{'title':'下载客户模板',
						'url':'/payment/list/','name':'payment_list'},
						{'title':'下载客户模板',
						'url':'/payment/list/','name':'payment_list'},
						{'title':'下载客户模板',
						'url':'/payment/list/','name':'payment_list'},
					]
				}
			}
			"""
			permission_queryset = models.Permission.objects.all().values('id','title','url','name','parent_id')

			root_permission_dict = {}
			for item in permission_queryset:
				print(item['parent_id'])
				if not item['parent_id']:
					root_permission_dict[item['id']] = {
						'title':item['title'],
						'url':item['url'],
						'name':item['name'],
						'children':[]
					}

			for item in permission_queryset:
				parent_id = item['parent_id']
				if parent_id:
					root_permission_dict[parent_id]['children'].append( {
						'title':item['title'],
						'url':item['url'],
						'name':item['name']
					})


			for root in root_permission_dict.values():
				print(root['title'],root['name'],root['url'])
				for node in root['children']:
					print('----->',node['title'],node['name'],node['url'])

			return HttpResponse('...')



家族结构

		2. 构造家族结构(存在多层children)
			comment_list = [
				{'id':1, 'title':'写的不错', 'pid':None}
				{'id':2, 'title':'还不错', 'pid':None}
				{'id':3, 'title':'什么万一', 'pid':1}
				{'id':4, 'title':'什么不错', 'pid':2}
				{'id':5, 'title':'x1', 'pid':1},
				{'id':6, 'title':'去你的吧', 'pid':3},
				{'id':7, 'title':'去你的吧', 'pid':6},
			]
			
			comment_list = [
				{'id':1, 'title':'写的不错', 'pid':None}, # ,children:[]
				{'id':2, 'title':'还不错', 'pid':None},
				{'id':3, 'title':'什么万一', 'pid':1},
				{'id':4, 'title':'什么不错', 'pid':2},
				{'id':5, 'title':'x1', 'pid':1},
				{'id':6, 'title':'去你的吧', 'pid':3},
				{'id':7, 'title':'去你的吧', 'pid':6},
			]
			comment_dict = {}
			for item in comment_list:
				item['children'] = []
				comment_dict[item['id']] = item
			comment_list[0]['title'] = 'asdfasdf'

			result = []
			for row in comment_list:
				if not row['pid']:
					result.append(row)
				else:
					pid = row['pid']
					comment_dict[pid]['children'].append(row)

			print(result)
			
			
'''			
			[
				{'id': 1, 'title': 'asdfasdf', 'pid': None, 
				 'children': [
					{'id': 3, 'title': '什么万一', 'pid': 1, 
					 'children': [
							{'id': 6, 'title': '去你的吧', 'pid': 3, 
							 'children': [
								{'id': 7, 'title': '去你的吧', 'pid': 6, 'children': []}
								]
							}
						]
					}, 
				
				{'id': 5, 'title': 'x1', 'pid': 1, 'children': []}]}, 
				
				{'id': 2, 'title': '还不错', 'pid': None, 
				 'children': [
						{'id': 4, 'title': '什么不错', 'pid': 2, 'children': []}
					]
				
				}
					
			]
'''				
```



#### 17.5 stark组件

##### 17.5.1 基础知识铺垫

```python
'''
1.类可以当作字典的key
'''
class User(object):
    pass

class Role(object):
    pass

class Bar(object):
    def __init__(self,b):
        self.b = b

_registry = {
    User:Bar(User),
    Role:Bar(Role)
}

for k,v in _registry.items():
    print(k,v.b)


'''
2.django中,获取model所在app名称、以及小写类名
'''
def index(request):
    
    print(m1.UserInfo._meta.app_label)  # models类所在app名称
    print(m1.UserInfo._meta.model_name) # models类类名小写
	
    
    # 给定字典获取app名称、类名小写
    _registry = {
        m1.UserInfo:'1',
        m2.Role:'2',
    }
    for k,v in _registry.items():
        print(k._meta.app_label,k._meta.model_name)

        return HttpResponse('...')

    
'''
3.简单的单例模式
'''

# zhaosen.py
class AdminSite(object):

    def __init__(self):
        self._registry = {}

obj1 = AdminSite()


调用实例：
import zhaosen 
zhaosen.obj1 
zhaosen.obj1 


'''
4.路由系统
'''
路由name的作用：起个别名，用于反向解析
路由namespace的作用：不同app之间可能存在同名的name，使用namespace用于区分不同的app


include()函数返回一个元组，
return (urlconf_module, app_name, namespace)

假设系统不提供该函数，可以使用下列方法导入路由：
urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^rbac/', ([
        				url(r'^login/', views.login),
        				url(r'^logout/', views.logout),
                        url(r'^x1/', ([
                            			url(r'^add/', views.add,name='n1'),
                            			url(r'^change/', views.change,name='n2'),
                        				],None,'xxx')
                           ),
    			],None,'rbac')
       ),
]



'''
5.启动后、路由加载前定制一段代码
django启动时先加载自己的配置文件，在配置文件中找到自己注册app的stark.apps.StarkConfig文件,然后执行这个类里面的ready()方法，然后路由加载之前在每个app找指定的stark.py文件【starkautodiscover_modules('stark')】，此时在路由录加入相关的条目，那么在路由加载时就会加载这些条目
'''
a. 创建一个stark app 组件		
b. 编写ready方法
    from django.apps import AppConfig
    class StarkConfig(AppConfig):
        name = 'stark'
        def ready(self):
            from django.utils.module_loading import autodiscover_modules
            autodiscover_modules('stark')

  程序启动时，会先去每个app中找stark.py文件并加载。

c. 其他app中创建stark.py 
d. 程序启动时便会自动加载 stark.py 




'''
6.方法[Method]和函数[Function]的区别:取决于调用的方式

class Foo(object):
	def display(self):
		pass

obj = Foo()

如果不在类里定义的明显是函数[Function]

在类里定义的，如果是使用对象调用的形式为方法[Method]  obj.display
使用类名调用的是函数[Function] Foo.display

'''


'''
7.生成器yield的作用
数据库有1000条数据，在视图函数查询时不需把所有数据加载到内存中，通过生成器可以一个个取出来

'''
def get_result(data_list):

    for row in data_list:
        temp = "%s%s" (row.name,row.pwd,)
        yield temp

def func(request):

    data_list = models.Users.objects.all()
    result = get_result(data_list)

    return render(request,'xxx.html',{'result':result})

xxx.html 

{% for row in result %}
{{row}}
{% endfor%}


'''
8.反射
反射是一个很重要的概念，它可以把字符串映射到实例的变量或者实例的方法然后可以去执行调用、修改等操作
它有四个重要的方法：
getattr 获取指定字符串名称的对象属性
setattr 为对象设置一个对象
hasattr 判断对象是否有对应的对象（字符串）
delattr 删除指定属性
'''

def test(request):
	from app01 import models

	list_display = ['id','title']
	
    # 通过模型的_meta获取模型的字段，再通过字段获取字段的属性
	header_list = []
	for name in list_display:
		header_list.append(models.UserInfo._meta.get_field(name).verbose_name)
	print(header_list)

    # 通过反射获取指定显示的列
	user_queryset = models.UserInfo.objects.all()
	for item in user_queryset:
		row = []
		for field in list_display:
			row.append(getattr(item,field))
		print(row)

	return HttpResponse('...')


'''
9.装饰器保留原函数名称
'''
import functools

def wrapper(func):
    @functools.wraps(func)
    def inner(*args, **kwargs):
        return func(*args, **kwargs)
    return inner

@wrapper
def f1():
    print('f1')

@wrapper
def f2():
    print('f1')


print(f1.__name__)  # f1
print(f2.__name__)  # f2


'''
10.django中使用 request.GET  --> QueryDict
高级操作
1.将_mutable设为True时，可以重新设置浏览器请求的变量值
2.以url编码的方式显示参数
'''
	def test(request):
		from django.http.request import QueryDict
		print(request.GET) # <QueryDict: {'k2': ['v2', 'v3'], 'k1': ['v1']}>

		# params = copy.deepcopy(request.GET)
		params = request.GET.copy()
        
         # 将_mutable设为True时，可以重新设置浏览器请求的变量值
		params._mutable = True   
		params['k1'] = 666
		params['k3'] = 78
		params.setlist('k4',[10,12])
		print(params['k2']) # request.GET.get('xx')

		old = params.getlist('k2')
		old.append('v4')
		params.setlist('k2',old)
		
        # 以url编码的方式显示参数
		v1 = params.urlencode()
		print(v1) # k1=v1&k2=v2&k2=v3
	
		return HttpResponse('...')
    
    
'''
11. 保留原来搜索条件
'''
def test(request):
    from django.http.request import QueryDict
    url_params_str = request.GET.urlencode() # _filter = k1=v1&k2=v2&k2=v3

    query_dict = QueryDict(mutable=True)
    query_dict['_filter'] = url_params_str

    new_params = query_dict.urlencode()

    target_url = "/add_stu/?%s" %new_params
    return redirect(target_url)

def add_stu(request):

    if request.method == "GET":
        return render(request,'add_stu.html')
    # 接收到数据，保存到数据库
    origin_params = request.GET.get('_filter')
    back_url = "/test/?%s" %origin_params
    return redirect(back_url)

'''
12.orm模糊搜索
如要完成下列操作：
name包含 ‘大’ 或 email包含 “大”
'''

q = Q()
q.connecter = "OR"
q.children.append(('name__contains', '大'))
q.children.append(('email__contains', '大'))


'''
13.python一切皆对象
方法也可以动态赋予属性
'''
def func():
    print(123)

func.text = "批量删除"


print(func.__name__)  # func
print(func.text)  # 批量删除


'''
14.mark_safe()函数
xss攻击是什么？
XSS跨站脚本攻击:黑客想尽一切方法 将一段脚本内容放到目标网站的目标浏览器上解释执行!!
'''
没有使用mark_safe()时，用户输入的和在浏览器显示的都是以字符串形式显示，

使用之后，表示要显示的字符串是安全的，那么如果里面含html标签或script脚本都会被浏览器解析



'''
15. 单例模式:
比如有个类，通过这个类你可以实例化，每个实例化对象都是独立的空间，各自都封装了数据，这是多例模式
那么单例模式，就是开始时我创建一个对象，就放在那里；其他地方有用到就只有这一个对象，而无需创建新的对象
'''

'''
16.可迭代对象
可以用其拓展属性内容
'''
	class Row(object):
		def __init__(self,data):
			self.data = data

		def __iter__(self):
			yield "<div>"
			yield '全部'
			for item in self.data:
				yield "<a href='/index/?p1=1.0'>%s</a>" %item
			yield "</div>"

	data_list= [
		Row(['1.0以下','1.1-1.6']),
		Row(['汽油','柴油','混合动力','电动']),
	]

	for row in data_list:
		for field in row:
			print(field)

'''
17.使用对象进行封装
'''        
2.封装 
		list_filter = [
			'董方方',
			'黄晓雪',
			'李贝贝',

		]

		# ############################ 老封装思想 ############################

		list_filter = [
			{'text':'董方方','gender':'男','color':'xx'}, # 字典对象做封装
			{'text':'黄晓雪','gender':'男','color':'xx'},
			{'text':'李贝贝','gender':'男','color':'xx'},
		]


		for item in list_filter:
			print(item['text'] + item['gender'])


		# ############################ 新封装思想 ############################
		class Option(object):
			def __init__(self,text,gender,color):
				self.text = text
				self.gender = gender
				self.color = color

			def get_t_g(self):
				return self.text +self.gender

		list_filter = [
			Option(text='董方方',gender='男',color = 'xx'), # 字典对象做封装
			Option(text='黄晓雪',gender='男',color = 'xx'), # 字典对象做封装
			Option(text='李贝贝',gender='男',color = 'xx'), # 字典对象做封装
		]

		for item in list_filter:
			print(item.get_t_g())


'''
18. 获取FK/M2M/O2O对应的表中所有的数据
fk_obj.rel.model.objects.all()
'''         
class UserInfo(models.Model):

	title = models.CharField(verbose_name='标题',max_length=32)


	def __str__(self):
		return self.title


class Depart(models.Model):

	name = models.CharField(verbose_name='部门名称',max_length=32)
	tel = models.CharField(verbose_name='联系电话',max_length=32)
	user = models.ForeignKey(verbose_name='负责人',to='UserInfo')

	def __str__(self):
		return self.name
		
def get_fk_queryset(request):
	from app01 import models

	fk_obj = models.Depart._meta.get_field("user")
	user_info_queryset = fk_obj.rel.model.objects.all()
	print(user_info_queryset)
	
	return HttpResponse('...')

'''
19.创建类:默认都是由type创建
type()函数
'''
name = "Foo"
country = "中国"
detail = lambda self, x: x + 1
# 根据以上三个参数创建一个类，类中有两个成员
"""
class Foo(object):
    country = '中国'
    def detail(self,x):
        return x + 1     
"""
cls = type(name, (object,), {'country': '中国', 'detail': lambda self, x: x + 1})

obj = cls()
print(obj.country)
print(obj.detail(100))


'''
10.偏函数：给函数传固定的参数
'''
import functools

def func(a1,a2):
    print(a1+a2)

new_func = functools.partial(func,8)

new_func(7)
new_func(2)
new_func(8)
```



##### 17.5.2 组件开发

```python
'''
1.启动后、路由加载前定制一段代码
django启动时先加载自己的配置文件，在配置文件中找到自己注册app的stark.apps.StarkConfig文件,然后执行这个类里面的ready()方法，然后路由加载之前在每个app找指定的stark.py文件【starkautodiscover_modules('stark')】，此时在路由录加入相关的条目，那么在路由加载时就会加载这些条目
'''
a. 创建一个stark app 组件		
b. 编写ready方法
    from django.apps import AppConfig
    class StarkConfig(AppConfig):
        name = 'stark'
        def ready(self):
            from django.utils.module_loading import autodiscover_modules
            autodiscover_modules('stark')

  程序启动时，会先去每个app中找stark.py文件并加载。

c. 其他app中创建stark.py 
d. 程序启动时便会自动加载 stark.py 


'''
2.对app下模型增删改查的路由自动添加到路由系统中
'''

项目下的urls.py

from django.conf.urls import url,include
from django.contrib import admin
from stark.service.stark import site  # 导入单例对象
from app01 import views

urlpatterns = [
    url(r'^stark/', site.urls),
]



'''
3.列表页的排序、页面内容定制（复选框、添加、编辑、删除按钮）
'''



'''
4.列表页的排序、添加、编辑、删除功能实现
'''



'''
5.列表页的复选框[批量操作]、关键词搜索、保留搜索条件、分页功能实现
'''



'''
6.组合搜索
基本配置==> 组合搜索显示 ==> 搜索url构建 ==> 支持点选和多选组合搜索 ==> 支持【全部】的功能搜索
'''
```



```python
'''
1. 通读源码 

2. 使用该组件处理以下关系 
   - 4张表
	  - 单表 
	  - fk
	  - m2m
	  - o2o
		- choice

'''


'''
1. 拆解其中涉及的知识点 
		面试官问：你这个项目怎么做的，这个项目有什么亮点，你这个项目遇到过哪些你印象深刻的事

2. 源码搞明白 
	


'''

```



### 18 rest_framework

#### 18.1 基础知识铺垫

![中间件](C:\Users\Administrator\Desktop\简历\image\中间件.png)

```python
1. 面向对象
	封装主要体现两点：
	 一是把相同的方法和属性封装到类中
	 二是通过构造方法将一部分数据封装到每一个对象里面
	 封装主要是为了打包方便以后使用
	 
	继承，为啥要有继承：
	如果两个类/或多个类有共同的属性和方法，那么就可以提取到它的父类里去实现
	这样就无需在每个类里实现
	
	多态：一种事物的多种形态
    
2.Django FBV请求生命周期
  uwsgi => 中间件 => 函数视图 => 中间件 => 客户端


3.django  CBV请求声明周期（包含rest framework框架）
   CBV，基于反射实现根据请求方式不同，执行不同的方法
    url ->as_views() -> view方法 -> dispatch方法（反射执行其他：GET/POST/DELETE/PUT）
    
    
4.django中间件
- process_request
- process_view
- process_response
- process_exception
- process_render_template

5. 使用中间件做过什么？
- 权限
- 用户登录验证
- django的csrf是如何实现？  # get时返回客户端一个csrf_token, post等方式访问时需要带上该token
在process_view方法，为什么在该方法实现，而不是在process_request实现？（有些视图需要额外免除csrf认证）
- 检查视图是否被 @csrf_exempt （免除csrf认证）
- 去请求体或cookie中获取token

6. csrf认证在FBV和CBV中的使用方式
情况一：
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware', # 全站使用csrf认证
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]


from django.views.decorators.csrf import csrf_exempt
@csrf_exempt # 该函数无需认证
def users(request):
    user_list = ['alex','oldboy']
    return HttpResponse(json.dumps((user_list)))

情况二：
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware', # 全站不使用csrf认证
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]


from django.views.decorators.csrf import csrf_exempt
@csrf_protect # 该函数需认证
def users(request):
    user_list = ['alex','oldboy']
    return HttpResponse(json.dumps((user_list)))


CBV小知识,csrf时需要使用
- @method_decorator(csrf_exempt)
- 在dispatch方法中（单独方法无效）

方式一：
from django.views.decorators.csrf import csrf_exempt,csrf_protect
from django.utils.decorators import method_decorator
class StudentsView(View):

    @method_decorator(csrf_exempt)
    def dispatch(self, request, *args, **kwargs):
        return super(StudentsView,self).dispatch(request, *args, **kwargs)

    def get(self,request,*args,**kwargs):
        print('get方法')
        return HttpResponse('GET')

    def post(self, request, *args, **kwargs):
        return HttpResponse('POST')

    def put(self, request, *args, **kwargs):
        return HttpResponse('PUT')

    def delete(self, request, *args, **kwargs):
        return HttpResponse('DELETE')
    
    方式二：
    from django.views.decorators.csrf import csrf_exempt,csrf_protect
    from django.utils.decorators import method_decorator

    @method_decorator(csrf_exempt,name='dispatch')
    class StudentsView(View):

        def get(self,request,*args,**kwargs):
            print('get方法')
            return HttpResponse('GET')

        def post(self, request, *args, **kwargs):
            return HttpResponse('POST')

        def put(self, request, *args, **kwargs):
            return HttpResponse('PUT')

        def delete(self, request, *args, **kwargs):
            return HttpResponse('DELETE')    

        
7.谈谈自己对restful api 规范的认识

首先restful是一种软件架构风格或者说是一种设计风格，并不是标准，
它只是提供了一组api设计原则和约束条件，主要用于客户端和服务器交互类的软件。     
就像设计模式一样，并不是一定要遵循这些原则，而是基于这个风格设计的软件可以更简洁，
更有层次，我们可以根据开发的实际情况，做相应的改变。
它里面提到了一些规范		

10个规则: https://www.cnblogs.com/wupeiqi/articles/7805382.html
   	#1.restful 提倡面向资源编程,在url接口中尽量要使用名词，不要使用动词 
				
    #2、在url接口中推荐使用Https协议，让网络接口更加安全
    #https://www.bootcss.com/v1/mycss？page=3
    #（Https是Http的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，
    #因此加密的详细内容就需要SSL（安全套接层协议））
				
    #3、在url中可以体现版本号
    #https://v1.bootcss.com/mycss
    #不同的版本可以有不同的接口，使其更加简洁，清晰     
				
    #4、url中可以体现是否是API接口 
    #https://www.bootcss.com/api/mycss 
				
	#5、url中可以添加条件去筛选匹配
	#https://www.bootcss.com/v1/mycss？page=3   
				
	#6、可以根据Http不同的method，进行不同的资源操作
	#（5种方法：GET / POST / PUT / DELETE / PATCH）
				
	#7、响应式应该设置状态码
				
	#8、有返回值，而且格式为统一的json格式   
				
	#9、返回错误信息
	#返回值携带错误信息     
				
	#10、返回结果中要提供帮助链接，即API最好做到Hypermedia
	#如果遇到需要跳转的情况 携带调转接口的URL
    ret = {
        code: 1000,
        data:{
            id:1,
            name:'小强',
            depart_id:http://www.luffycity.com/api/v1/depart/1/
        }
    }        
```



#### 18.2 rest_framework之认证

```python
# 1.认证的使用
- 创建类:继承BaseAuthentication； 实现：authenticate方法
- 返回值：
	- None,我不管了，下一认证来执行。
	- raise exceptions.AuthenticationFailed('用户认证失败') # from rest_framework import exceptions
	- (元素1，元素2)  # 元素1赋值给request.user; 元素2赋值给request.auth 
	
- 局部使用
	from rest_framework.authentication import BaseAuthentication,BasicAuthentication
    class FirstAuthtication(BaseAuthentication):
        def authenticate(self,request):
            pass
		
        # 继承了BaseAuthentication可以不用重写authenticate_header方法
        def authenticate_header(self, request):
            pass

    class Authtication(BaseAuthentication):
        def authenticate(self,request):
            token = request._request.GET.get('token')
            token_obj = models.UserToken.objects.filter(token=token).first()
            if not token_obj:
                raise exceptions.AuthenticationFailed('用户认证失败')
            # 在rest framework内部会将整个两个字段赋值给request，以供后续操作使用
            return (token_obj.user, token_obj)
		
        # 继承了BaseAuthentication可以不用重写authenticate_header方法
        def authenticate_header(self, request):
            return 'Basic realm="api"'  
        
	class UserInfoView(APIView):
		"""
		订单相关业务
		"""
		authentication_classes = [Authtication,]
		def get(self,request,*args,**kwargs):
			print(request.user)
			return HttpResponse('用户信息')
        
- 全局使用：
REST_FRAMEWORK = {
    # 全局使用的认证类
   "DEFAULT_AUTHENTICATION_CLASSES":                                ['api.utils.auth.FirstAuthtication','api.utils.auth.Authtication', ],
    # "UNAUTHENTICATED_USER":lambda :"匿名用户"
    "UNAUTHENTICATED_USER":None, # 匿名，request.user = None
    "UNAUTHENTICATED_TOKEN":None,# 匿名，request.auth = None
}




# 2.认证源码流程

c. 认证流程原理
 -> 路由as_view() => 执行 APIView中的as_view() 
	=> 执行父类View中的super().as_view(**initkwargs),在该方法中的内部方法view调用dispatch()
	
 -> 执行 APIView中的dispatch() 
	=>执行APIView中的self.initialize_request(request, *args, **kwargs)封装Request
	=> 在封装Request中有调用authenticators=self.get_authenticators()
	
 ->执行APIView中的get_authenticators(self)的方法
   => 列表生成式实例化对象再返回return [auth() for auth in self.authentication_classes]
   => 如果在我们定义的UserInfoView中定义了authentication_classes列表，就用该列表
   
 -> 回到dispatch() 方法，继续执行APIView中的self.initial(request, *args, **kwargs)
	 => 在该方法中执行APIView的self.perform_authentication(request),执行request.user
	 => 即执行Request模块中的def user(self)方法，继续调用Request模块的self._authenticate()
	 
	 => 最后遍历刚刚封装Request中属性authenticators的列表
	 =>1.如果authenticate抛出异常，则执行self._not_authenticated()
	 =>2.如果有返回值，必须是元组，其中第一个赋值给request.user, 第二个赋值给request.auth
	 =>3.返回None,则继续遍历authenticators的列表，如果全都返回None,则执行self._not_authenticated()
	 
	 => 执行self._not_authenticated(),给request.user=AnonymousUser，request.auth=None

-> 回到dispatch() 方法，通过反射执行相应的get/post方法
    

内置认证类
1. 认证类，必须继承：from rest_framework.authentication import BaseAuthentication
2. 其他认证类：BasicAuthentication    
```



#### 18.2 rest_framework之权限

```python
# 不同视图不同权限可以访问

# 1.权限的使用

# 局部使用
class SVIPPermission(BasePermission):
    message = "必须是SVIP才能访问"
    def has_permission(self,request,view):
        if request.user.user_type != 3:
            return False
        return True
								

class OrderView(APIView):
	"""
	订单相关业务(只有SVIP用户有权限)
	"""
	permission_classes = [SVIPPermission,]
	
	def get(self,request,*args,**kwargs):
		# request.user
		# request.auth
		self.dispatch
		ret = {'code':1000,'msg':None,'data':None}
		try:
			ret['data'] = ORDER_DICT
		except Exception as e:
			pass
		return JsonResponse(ret)
    
    
# 全局使用
# （如果类视图没有定义permission_classes，就默认调用该类进行权限校验，
#   如果类视图定义了permission_classes，则不使用该类进行权限校验）
REST_FRAMEWORK = {
    # 全局使用的权限类
    "DEFAULT_PERMISSION_CLASSES":['api.utils.permission.SVIPPermission'],
}


# 2.权限源码流程

c. 权限流程原理
 -> 路由as_view() => 执行 APIView中的as_view() 
	=> 执行父类View中的super().as_view(**initkwargs),在该方法中的内部方法view调用dispatch()
	
 -> 执行 APIView中的dispatch() 
	=>执行APIView中的self.initialize_request(request, *args, **kwargs)封装Request
   
 -> 回到dispatch() 方法，继续执行APIView中的self.initial(request, *args, **kwargs)
	 => 在该方法中执行APIView的self.check_permissions(request)
	 => 在self.check_permissions(request)方法中
        通过self.get_permissions()以列表推导式获取权限设置类并实例化权限设置类，默认读配置文件
     => 遍历该权限设置对象列表，调用对象的has_permission(request, self)方法
        如果返回True，则执行结束表示有权限，否则调用self.permission_denied()抛出异常表示没权限
	
-> 回到dispatch() 方法，通过反射执行相应的get/post方法

内置权限类
1. 权限类，必须继承：from rest_framework.permissions import BasePermission

```



#### 18.3 rest_framework之访问频率控制（节流）

```python
# 1.自定义访问频率控制的使用

# 局部使用
import time
VISIT_RECORD = {}

class VisitThrottle(object):
    """10s内只能访问3次"""

    def __init__(self):
    self.history = None

    def allow_request(self,request,view):
        # 1. 获取用户IP
        remote_addr = request.META.get('REMOTE_ADDR')
        ctime = time.time()
        if remote_addr not in VISIT_RECORD:
            VISIT_RECORD[remote_addr] = [ctime,]
            return True
        history = VISIT_RECORD.get(remote_addr)
        self.history = history

        while history and history[-1] < ctime - 10:
            history.pop()

        if len(history) < 3:
            history.insert(0,ctime)
            return True

        # return True    # 表示可以继续访问
        # return False # 表示访问频率太高，被限制

    def wait(self):
        """
        还需要等多少秒才能访问
        :return:
        """
        ctime = time.time()
        return 10 - (ctime - self.history[-1])

class AuthView(APIView):
    """
    用于用户登录认证
    """
    authentication_classes = []
    permission_classes = []
    throttle_classes = [VisitThrottle,]

    def post(self,request,*args,**kwargs):
        ret = {'code':1000,'msg':None}
        try:
            user = request._request.POST.get('username')
            pwd = request._request.POST.get('password')
            obj = models.UserInfo.objects.filter(username=user,password=pwd).first()
            if not obj:
                ret['code'] = 1001
                ret['msg'] = "用户名或密码错误"
            # 为登录用户创建token
            token = md5(user)
            # 存在就更新，不存在就创建
            models.UserToken.objects.update_or_create(user=obj,defaults={'token':token})
            ret['token'] = token
        except Exception as e:
            ret['code'] = 1002
            ret['msg'] = '请求异常'

        return JsonResponse(ret)

    
# 全局使用
# （如果类视图没有定义permission_classes，就默认调用该类进行节流校验，
#   如果类视图定义了permission_classes，则不使用该类进行节流校验）
REST_FRAMEWORK = {
    # 全局使用的节流类
    "DEFAULT_PERMISSION_CLASSES":['api.utils.throttle.UserThrottle'],
}    


# 2.节流源码流程
	类似权限源码流程

内置节流类
1. 节流类，必须继承：from rest_framework.throttling import BaseThrottle,SimpleRateThrottle

class VisitThrottle(SimpleRateThrottle):
	scope = "Luffy"  # 通过该字段获取配置文件中的控制频率，源码里有拆分

	def get_cache_key(self, request, view):
		return self.get_ident(request)


class UserThrottle(SimpleRateThrottle):
	scope = "LuffyUser"

	def get_cache_key(self, request, view):
		return request.user.username

    
class UserInfoView(APIView):
    """
    订单相关业务（普通用户、VIP）
    """
    throttle_classes = [UserThrottle,]

    def get(self,request,*args,**kwargs):
        return HttpResponse('用户信息')
    
    
REST_FRAMEWORK = {
	# 全局使用的认证类
	"DEFAULT_AUTHENTICATION_CLASSES":[
	"DEFAULT_THROTTLE_CLASSES":["api.utils.throttle.UserThrottle"],
	"DEFAULT_THROTTLE_RATES":{
		"Luffy":'3/m',
		"LuffyUser":'10/m',
	}
}

```



#### 18.3 rest_framework之解析器

```python
# 1.解析器的使用

# 局部使用
# 全局使用
https://www.cnblogs.com/wupeiqi/articles/7805382.html

    
2. 解析器
前戏：django:request.POST/ request.body
	1. 请求头要求：
		Content-Type: application/x-www-form-urlencoded
		PS: 如果请求头中的 Content-Type: application/x-www-form-urlencoded，request.POST中才有值（去request.body中解析数据）。
	2. 数据格式要求：
		  name=alex&age=18&gender=男

	如：
		a. form表单提交
			<form method...>
				input...
				
			</form>
			
		b. ajax提交
			$.ajax({
				url:...
				type:POST,
				data:{name:alex,age=18} # 内部转化 name=alex&age=18&gender=男
			})
			
			情况一：
				$.ajax({
					url:...
					type:POST,
					headers:{'Content-Type':"application/json"}
					data:{name:alex,age=18} # 内部转化 name=alex&age=18&gender=男
				})
				# body有值；POST无
			情况二：
				$.ajax({
					url:...
					type:POST,
					headers:{'Content-Type':"application/json"}
					data:JSON.stringfy({name:alex,age=18}) # {name:alex,age:18...}
				})
				# body有值；POST无
				# json.loads(request.body)
			
rest_framework 解析器，对请求体数据进行解析
	
总结：
	使用：	
		配置：
        REST_FRAMEWORK = {
            "DEFAULT_VERSIONING_CLASS":"rest_framework.versioning.URLPathVersioning",
            "DEFAULT_VERSION":'v1',
            "ALLOWED_VERSIONS":['v1','v2'],
            "VERSION_PARAM":'version',

            "DEFAULT_PARSER_CLASSES":['rest_framework.parsers.JSONParser','rest_framework.parsers.FormParser']
        }
						
		使用：
			class ParserView(APIView):
				# parser_classes = [JSONParser,FormParser,]
				"""
				JSONParser:表示只能解析content-type:application/json头
				FormParser:表示只能解析content-type:application/x-www-form-urlencoded头
				"""

				def post(self,request,*args,**kwargs):
					"""
					允许用户发送JSON格式数据
						a. content-type: application/json
						b. {'name':'alex',age:18}
					:param request:
					:param args:
					:param kwargs:
					:return:
					"""
					"""
					1. 获取用户请求
					2. 获取用户请求体
					3. 根据用户请求头 和 parser_classes = [JSONParser,FormParser,] 中支持的请求头进行比较
					4. JSONParser对象去请求体
					5. request.data
					"""
					print(request.data)


					return HttpResponse('ParserView')
					
    
```



#### 18.4 rest_framework之序列化器(Serializer、ModelSerializer)

```python
# Serializer与ModelSerializer 和 Form与ModelForm类似

# 1、Serializer的使用(存在choices、一对多、多对多)

# 模型models.py
class UserGroup(models.Model):
    title = models.CharField(max_length=32)
    
class Role(models.Model):
    title = models.CharField(max_length=32)
    
class UserInfo(models.Model):
    user_type_choices = (
        (1,'普通用户'),
        (2,'VIP'),
        (3,'SVIP'),
    )
    user_type = models.IntegerField(choices=user_type_choices)

    username = models.CharField(max_length=32,unique=True)
    password = models.CharField(max_length=64)

    group = models.ForeignKey("UserGroup")
    roles = models.ManyToManyField("Role")    


 # views.py
class UserInfoSerializer(serializers.Serializer):
    xxxxx = serializers.CharField(source="user_type") # row.user_type()
    oooo = serializers.CharField(source="get_user_type_display") # row.get_user_type_display()
    username = serializers.CharField()
    password = serializers.CharField()
    gp = serializers.CharField(source="group.title")   # 一对多
    # rls = serializers.CharField(source="roles.all")
    rls = serializers.SerializerMethodField() # 自定义显示  # 多对多

    def get_rls(self,row):

        role_obj_list = row.roles.all()

        ret = []
        for item in role_obj_list:
            ret.append({'id':item.id,'title':item.title})
        return ret
    
    
class UserInfoView(APIView):
    def get(self,request,*args,**kwargs):

        users = models.UserInfo.objects.all()

        # 对象， Serializer类处理； self.to_representation
	    # QuerySet，ListSerializer类处理； self.to_representation
        ser = UserInfoSerializer(instance=users,many=True)
        ret = json.dumps(ser.data, ensure_ascii=False)
        return HttpResponse(ret)    
    
    
    
# 2、ModelSerializer的使用(存在choices、一对多、多对多) 
class UserInfoSerializer(serializers.ModelSerializer):
    oooo = serializers.CharField(source="get_user_type_display")  # row.user_type
    rls = serializers.SerializerMethodField()  # 自定义显示

    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','oooo','rls','group']

    def get_rls(self, row):
        role_obj_list = row.roles.all()

        ret = []
        for item in role_obj_list:
            ret.append({'id':item.id,'title':item.title})
        return ret

    
    
# 3.ModelSerializer的使用值序列化深度控制
3. 自动序列化连表
class UserInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','group','roles']
        depth = 1 # 0 ~ 10

```

![1591542630651](C:\Users\Administrator\Desktop\简历\image\序列化.png)

```python
# 4.序列化生成hypermedialink
# urls.py
urlpatterns = [

    url(r'^(?P<version>[v1|v2]+)/group/(?P<xxx>\d+)$', views.GroupView.as_view(),name='gp'),
]


# views.py
class UserInfoSerializer(serializers.ModelSerializer):
    group = serializers.HyperlinkedIdentityField(view_name='gp',lookup_field='group_id',lookup_url_kwarg='xxx')
    class Meta:
        model = models.UserInfo
        # fields = "__all__"
        fields = ['id','username','password','group','roles']
        depth = 0 # 0 ~ 10
        
class UserInfoView(APIView):
    def get(self,request,*args,**kwargs):

        users = models.UserInfo.objects.all()

        # 对象， Serializer类处理； self.to_representation
	    # QuerySet，ListSerializer类处理； self.to_representation
        ser = UserInfoSerializer(instance=users,many=True,context={'request': request})
        ret = json.dumps(ser.data, ensure_ascii=False)
        return HttpResponse(ret)        
```

![1591543758440](C:\Users\Administrator\Desktop\简历\image\序列化02.png)



#### 18.5 rest_framework之验证用户请求数据

```python
class XXValidator(object):
    def __init__(self, base):
        self.base = base

    def __call__(self, value):
        if not value.startswith(self.base):
            message = '标题必须以 %s 为开头。' % self.base
            raise serializers.ValidationError(message)

    def set_context(self, serializer_field):
        """
        This hook is called by the serializer instance,
        prior to the validation call being made.
        """
        # 执行验证之前调用,serializer_fields是当前字段对象
        pass

class UserGroupSerializer(serializers.Serializer):
    title = serializers.CharField(error_messages={'required':'标题不能为空'},validators=[XXValidator('老男人'),])


class UserGroupView(APIView):

    def post(self,request,*args,**kwargs):

        ser = UserGroupSerializer(data=request.data)
        if ser.is_valid():
            print(ser.validated_data['title'])
        else:
            print(ser.errors)

        return HttpResponse('提交数据')
    
    
问： 自定义验证规则时，需要钩子函数？请问钩子函数如何写？    
```



#### 18.6 rest_framework之分页

```python
# a. 分页，看第n页，每页显示n条数据；
from rest_framework.pagination import PageNumberPagination

class MyPageNumberPagination(PageNumberPagination):

	page_size = 2   # 设置每页显示多少条
	page_size_query_param = 'size'   # 可以通过该关键字设置每页显示多少条
	max_page_size = 5                # 控制每页显示最大条数
	page_query_param = 'page'

class Pager1View(APIView):

	def get(self,request,*args,**kwargs):

		# 获取所有数据
		roles = models.Role.objects.all()

		# 创建分页对象
		# pg = MyPageNumberPagination()
		pg = PageNumberPagination()

		# 在数据库中获取分页的数据
		pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

		# 对数据进行序列化
		ser = PagerSerialiser(instance=pager_roles, many=True)

		return Response(ser.data)
		# return pg.get_paginated_response(ser.data)  # 提供下一页和上一页的url      
        
```

![1591551698073](C:\Users\Administrator\Desktop\简历\image\分页01.png)

![1591551763393](C:\Users\Administrator\Desktop\简历\image\分页02.png)



```python
# b. 分页，在n个位置，向后查看n条数据；
			
from api.utils.serializsers.pager import PagerSerialiser
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination,LimitOffsetPagination


class MyLimitOffsetPagination(LimitOffsetPagination):
	default_limit = 2
	limit_query_param = 'limit'
	offset_query_param = 'offset'
	max_limit = 5


class Pager1View(APIView):

	def get(self,request,*args,**kwargs):

		# 获取所有数据
		roles = models.Role.objects.all()

		# 创建分页对象
		# pg = MyLimitOffsetPagination()
		pg = LimitOffsetPagination()

		# 在数据库中获取分页的数据
		pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

		# 对数据进行序列化
		ser = PagerSerialiser(instance=pager_roles, many=True)

		return Response(ser.data)
		# return pg.get_paginated_response(ser.data)
```

![1591551846628](C:\Users\Administrator\Desktop\简历\image\分页03.png)



```python
# c. 加密分页，上一页和下一页。

from api.utils.serializsers.pager import PagerSerialiser
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination,LimitOffsetPagination,CursorPagination

class MyCursorPagination(CursorPagination):
	cursor_query_param = 'cursor'
	page_size = 2
	ordering = 'id'
	page_size_query_param = None
	max_page_size = None

class Pager1View(APIView):

	def get(self,request,*args,**kwargs):

		# 获取所有数据
		roles = models.Role.objects.all()

		# 创建分页对象
		# pg = CursorPagination()
		pg = MyCursorPagination()

		# 在数据库中获取分页的数据
		pager_roles = pg.paginate_queryset(queryset=roles,request=request,view=self)

		# 对数据进行序列化
		ser = PagerSerialiser(instance=pager_roles, many=True)

		# return Response(ser.data)
		return pg.get_paginated_response(ser.data)
```

![1591552203396](C:\Users\Administrator\Desktop\简历\image\分页04.png)



#### 18.6 rest_framework之视图

```python

# 1.GenericAPIView
# 和APIview功能类似，只是提供了一些方法方便操作

from api.utils.serializsers.pager import PagerSerialiser
from rest_framework.generics import GenericAPIView

class View1View(GenericAPIView): # APIView
	queryset = models.Role.objects.all()
	serializer_class = PagerSerialiser
	pagination_class = PageNumberPagination
	def get(self,request,*args,**kwargs):
		# 获取数据
		roles = self.get_queryset() # models.Role.objects.all()

		# [1, 1000,]     [1,10]
		pager_roles = self.paginate_queryset(roles)

		# 序列化
		ser = self.get_serializer(instance=pager_roles,many=True)

		return Response(ser.data)


# 2.GenericViewSet(ViewSetMixin, generics.GenericAPIView):
		
	路由：
		# 设置对应关系
		url(r'^(?P<version>[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list'})),
	
	视图：
		from api.utils.serializsers.pager import PagerSerialiser
		from rest_framework.viewsets import GenericViewSet

		class View1View(GenericViewSet):
			queryset = models.Role.objects.all()
			serializer_class = PagerSerialiser
			pagination_class = PageNumberPagination

			def list(self, request, *args, **kwargs):
				# 获取数据
				roles = self.get_queryset()  # models.Role.objects.all()

				# [1, 1000,]     [1,10]
				pager_roles = self.paginate_queryset(roles)

				# 序列化
				ser = self.get_serializer(instance=pager_roles, many=True)

				return Response(ser.data)
				
# 3.ModelViewSet

	路由系统：
		url(r'^(?P<version>[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list','post':'create'})),
		url(r'^(?P<version>[v1|v2]+)/v1/(?P<pk>\d+)/$', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put':'update','patch':'partial_update'})),

	视图：
		from api.utils.serializsers.pager import PagerSerialiser
		from rest_framework.viewsets import GenericViewSet,ModelViewSet
		from rest_framework.mixins import ListModelMixin,CreateModelMixin

		class View1View(ModelViewSet):
			queryset = models.Role.objects.all()
			serializer_class = PagerSerialiser
			pagination_class = PageNumberPagination
			
		PS: class View1View(CreateModelMixin,GenericViewSet):
总结：
	a. 增删改查 ModelViewSet
	b. 增删     CreateModelMixin,DestroyModelMixin  GenericViewSet
	c. 复杂逻辑  GenericViewSet 或 APIView 
    

```



#### 18.6 rest_framework之路由

```python
a. 
	url(r'^(?P<version>[v1|v2]+)/parser/$', views.ParserView.as_view()),
	
b. 
	url(r'^(?P<version>[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list','post':'create'})),

c. 
	# http://127.0.0.1:8000/api/v1/v1/?format=json
	url(r'^(?P<version>[v1|v2]+)/v1/$', views.View1View.as_view({'get': 'list','post':'create'})),
	
	# http://127.0.0.1:8000/api/v1/v1.json
	url(r'^(?P<version>[v1|v2]+)/v1\.(?P<format>\w+)$', views.View1View.as_view({'get': 'list','post':'create'})),

	url(r'^(?P<version>[v1|v2]+)/v1/(?P<pk>\d+)/$', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put':'update','patch':'partial_update'})),
	url(r'^(?P<version>[v1|v2]+)/v1/(?P<pk>\d+)\.(?P<format>\w+)$', views.View1View.as_view({'get': 'retrieve','delete':'destroy','put':'update','patch':'partial_update'})),

d. 
	from api import views
	from rest_framework import routers


	router = routers.DefaultRouter()
	router.register(r'xxxxx', views.View1View)
	router.register(r'rt', views.View1View)

	urlpatterns = [
		url(r'^(?P<version>[v1|v2]+)/', include(router.urls)),
	]

```



#### 18.6 rest_framework之渲染器

```python
from rest_framework.renderers import JSONRenderer,BrowsableAPIRenderer

class TestView(APIView):
	# renderer_classes = [JSONRenderer,BrowsableAPIRenderer]
	def get(self, request, *args, **kwargs):
		# 获取所有数据
		roles = models.Role.objects.all()

		# 创建分页对象
		# pg = CursorPagination()
		pg = MyCursorPagination()

		# 在数据库中获取分页的数据
		pager_roles = pg.paginate_queryset(queryset=roles, request=request, view=self)

		# 对数据进行序列化
		ser = PagerSerialiser(instance=pager_roles, many=True)

		return Response(ser.data)
		
		
REST_FRAMEWORK = {
	"DEFAULT_VERSIONING_CLASS":"rest_framework.versioning.URLPathVersioning",
	"DEFAULT_VERSION":'v1',
	"ALLOWED_VERSIONS":['v1','v2'],
	"VERSION_PARAM":'version',
	"DEFAULT_PARSER_CLASSES":['rest_framework.parsers.JSONParser','rest_framework.parsers.FormParser'],
	"PAGE_SIZE":2,
	
	"DEFAULT_RENDERER_CLASSES":[
		'rest_framework.renderers.JSONRenderer',
		'rest_framework.renderers.BrowsableAPIRenderer',
	]
}

```

