#### Javascript

##### 一、标识符、数据类型与运算符

```javascript
1、 导入JavaScript标签: 
	<script type=“text/javascript”>js代码</script>
	<script type="text/javascript" src="js/demo.js"></script>  //引入外部js

2、js输入与输出：
    第一句javascript代码：alert(“弹出窗口”) ; 
    第二句javascript代码：document.write(“亲，我在页面上，跟alert不一样噢！”);
    第三句javascript代码：console.log(“我是在控制台打印的, 以后常用我！”);
	第四句javascript代码：prompt("弹出输入框")

3、 script标签可以出现多次, 且可以出现在html文件的任何地方, 建议写在<head></head>之间; 另外,同一个文件中Javascript和HTML代码, 它们的执行顺序都是自上而下，谁在前就谁先执行, 谁在后就后执行.

4、  JavaScript的注释
     单行注释: //,    
	 多行注释 /* */

5、JS中的数据类型
 	* 一、基本数据类型
		* 1、数字(Number)：包括浮点数与整数（特殊值NaN）
		* 2、字符串(String)：包括由任意数量字符组成的序列
		* 3、布尔值(Boolean)：包括true和false
		* 4、undefined(只有一个值：undefined)：
        	 当我们试图访问一个不存在的变量时，就会得到一个特殊的值undefined。
        	 除此之外，使用已定义却未赋值的变量也会如此，以为js会自动将变量在初始化之前的值
             设定为undefined。而Undefined类型的值只有一个，那就是undefined
             
		* 5、null（只包含一个值null值）：
             只包含一个值的特殊数据类型。所谓的null值，通常是没有值或空值，
        	不代表任何东西。null与undefined最大的不同在于，被赋予null的变量通常被认为是已经
            定义了的，只不过它不代表任何东西。
            
            undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true,
            表示值相等， 但是两者的数据类型是不一样的。
		 * 6、Object：对象{ }  数组Array [ ]  
            
     二、类型判断typeof:
			var age = 10;
			var age2;
			console.log(typeof age);  // number
			console.log(typeof age2);  //undefined

		//tt1 = new undefined()  //undefined is not a constructor
		//tt2 = new null()  //null is not a constructor
		console.log(typeof undefined)  //undefined
		console.log(typeof null)  //object

		//undefined
		var a 
		console.log(Boolean(undefined)) //false
		console.log(undefined == a);  //true
		console.log(undefined == 0);  //false
		console.log(undefined == "");  //false
		console.log(undefined == " ");  //false
		console.log(undefined == false);  //false
		console.log(undefined == true);  //false
		
		console.log("*".repeat(50))
		
		//null
		var b =null
		console.log(null == b);  //true
		console.log(null == 0);  //false
		console.log(null == "");  //false
		console.log(null == " ");  //false
		console.log(null == false);  //false

	
		console.log(undefined == null);  //true
		console.log(Boolean(undefined) == Boolean(null)) //true
		console.log(undefined === null);  //false

		//str
		var str = ""
		var str2 = new String()
		console.log(typeof str);  //string
		console.log(typeof str2);  //object
		console.log(str == str2);  //true
		console.log(str === str2);  //false
	
		//对象
		var obj = {}
		var obj2 = new Object()
		console.log(typeof obj);  //object
		console.log(typeof obj2);  //object
		console.log(obj);  //{}
		console.log(obj2);  //{}
		console.log(obj == obj2);  //false  相当于创建两个对象,不相等
		console.log(obj === obj2);  //false

		//isNaN(info)  判断值是否是NaN，如果info===NaN则返回true，否则返回false
			
		console.log(isNaN(NaN));//true
		console.log(isNaN(parseInt("abc")));//true
		console.log(isNaN(123));

6、变量的命名规范
    1. 变量名可以是数字,字母,下划线_和美元符$组成;
    2. 第一个字符不能为数字
    3. 不能使用关键字或保留字
    4. 标识符区分大小写，如：age和Age是不同的变量。但强烈不建议用同一个单词的大小写区分两个变量。
    5. 变量命名尽量遵守驼峰原则: myStudentScore小驼峰， 大驼峰MyStudentScore
    6. 变量命名尽量见名思意

		
7、JS运算符
    算术运算符 ： +，-, *, /, %(取余数)
    字符串和变量的拼接： +
    关系运算符 ： <、>、<=、>=、==、===、!=, !==
    逻辑运算符 ： &&  与(且)、||  或、!  非
    赋值运算符 ：  =、+=、-=、*=、/=、%=
    自增、自减 ： ++a, a++, --a, a--
    三目运算符： ? : 
    
    
    // +
    console.log("hello" + "wordle") //hellowordle
    console.log("hello" + 100)  //hello100
    console.log("hello" + true)  //hellotrue
    console.log("hello" + 1 + 2)  //hello12
    console.log("hello" + (1 + 2))  //hello3

```



##### 二、分支与循环

```javascript

1、var和let区别
//var 会提前声明,let不会提前声明
//let 不能重复定义同一个变量
console.log(b)  //undefined  不是not define,声明了但未初始化
console.log(c) //报错,
var b = 10
let c = 10
console.log(b) //10
console.log(c) //10


/* 在函数中无论是用var还是let定义的变量都是该函数的局部变量
   在循环中使用var定义的是全局变量，使用let定义的变量会形成作用域属于局部变量
*/
function ceshi(){
    var a=10
    let b=10
    }

if(1){
    var c = 10
    let d = 10
    }
console.log(a)  //a is not defined
console.log(b)  //b is not defined
console.log(c)  //10 
console.log(d)  //d is not defined

2、常量
//常量(一旦初始化不能修改)
const PI = 3.14
PI = 3   //报错


3、for-in
//for-in
let arr = [1,2,3,4]
for (let i in arr){
    console.log('i:'+i+','+arr[i])
}

/*	i:0,1
	i:1,2,
	i:2,3,
	i:3,4*/


4、for循环
//for
// 1, 一个新入职，月工资为2000元的员工，每年涨当年工资5%，20年后的月工资是多少？

let salary = 2000
for(var i=1; i<=20; i++){
    salary = salary + salary*0.05
}

console.log(salary)




// 2, 山上有一口缸可以装50升水，现在有15升水。老和尚叫小和尚下山挑水，每次可以挑5升。问：小和尚要挑几次水才可以把水缸挑满？通过编程解决这个问题。

let num = 0
for(var i=15; i <50 ; i+=5 ){
    num++
}

console.log(num)


// 3, 计算10的阶乘   

let jiec = 1
for(var i=2; i<=10; i++){
    jiec = jiec*i
}
console.log(jiec)



// 4, 99乘法表
for(var i=1; i<=9; i++){
    for(var j=1; j<=i; j++){
        document.write(j+'*'+i+'='+(j*i)+'&nbsp;&nbsp;')
    }
    document.write("<br />")
}
//document.write("hello<br>world")  //能够解析HTML

// 5, 求: 1-1/2+1/3-1/4 …  1/100的和
let sum2 = 0
for (var i=1; i <= 100; i++){
    if (i%2==0) {
        sum2 = sum2 - (1/i)
    } else{
        sum2 = sum2 + (1/i)
    }
}
console.log(sum2)




// 6, 求1!+2!+3!+4!+5! 

let sumnjie = 0
for(var i=1; i<=5; i++){
    var jiecl = 1
    for (var j=1; j<=i; j++){
        jiecl = jiecl * j
    }								

    sumnjie += jiecl
}

console.log('jice:'+sumnjie)


// 7, 找出所有的水仙花数，三位数，各位立方和等于该数本身。
//      如: 153 = 1 ^ 3 + 5 ^ 3 + 3 ^ 3 

// let shui = 153
var ge,shi,bai
for(var i=100; i<1000; i++){
    ge = i % 10
    shi = parseInt(i / 10) % 10
    bai = parseInt(i / 100)
    if(i == (Math.pow(bai,3)+Math.pow(shi,3)+Math.pow(ge,3))){
        console.log(i)					
    }
}


// 8, 宰相的麦子：相传古印度宰相达依尔，是国际象棋的发明者。有一次，国王因为他的贡献要奖励他，问他想要什么。
//达依尔说：“只要在国际象棋棋盘上（共64格）摆上这么些麦子就行了：第一格一粒，第二格两粒，……，
//后面一格的麦子总是前一格麦子数的两倍，摆满整个棋盘，我就感恩不尽了。”国王一想，这还不容易，刚想答应，
//如果你这时在国王旁边站着，你会不会劝国王别答应，为什么？
// 1 1
// 2 2
// 3 4
// 4 8

let sum3 = 0
for (var i=1; i<=64; i++){
    sum3 = sum3 + Math.pow(2,i-1)				
}
console.log(sum3)
```



##### 三、函数

```javascript
/**
* 函数概述(函数的声明)：
* function 函数名(参数列表) {
*     语句
*     return 表达式;
* }
* 1、function：是函数的关键词
* 2、函数名：遵循标识符的规则
* 3、()：参数列表的开始和结束
* 4、参数列表：函数从函数的调用者获得的信息，可以没有参数
* 5、{}：函数体的开始和结束
* 6、语句：函数封装的功能
* 7、return 表达式：return一般用于结束函数，并返回给函数的调用者一些信息，"表达式"即为要返回的数据。如果一个函数没有显示的返回return子句，我们就默认它的返回值为undefined。
*
* 注意：在仅仅只声明之后是不会被执行的，只是说明有了一个能完成该功能的函数，还没有被使用
* 
*/

/*********************
1、函数定义与使用：
**********************/
    var quju = 10;
    console.log(typeof func); //function  //函数会提前定义

    function func(num1, num2) {
        var num3 = 20;  //函数的局部变量
        num4 = 30;  	//声明一个变量时没有使用var语句，该变量就会被默认为全局的
        quju++;  	    //函数内部可以向访问自己的局部变量那样访问全局变量

        return num1+num2
    }

    console.log(func(10,20));
    //console.log(num3);  //num3 is not defined，访问不到函数中的局部变量
    console.log(num4);   //30
    console.log(quju);   //11


/*********************
2、函数传参原理：
**********************/
//传参原理:实参会先传给arguments数组,形参再从数组中获取
function fn3(a, b){
    console.log(a, b)  //1 23
    console.log(arguments)  //Arguments(4) [1, 23, 43, 45, callee: ƒ, Symbol: ƒ]
    console.log(arguments[0])  //1
    console.log(arguments.length)  //4

    console.log(this)  //window对象
    //关键字,谁调用函数fn3,则this就是谁
}
fn3(1,23,43,45) 


/*********************
3、匿名函数：
**********************/
//通过这种方式定义的函数被称为匿名函数(即没有名字的函数)，特别上当它不被赋值给变量单独使用时，可以有两种优雅的用法。
//1、可以将匿名函数作为参数传递给其他函数
//2、定义匿名函数完成某些一次性任务
function fun(num1, num2, fc) {
    return fc(num1, num2);
}

var num = fun(1,2,function(a,b){
    return a + b;
});
console.log("num = " + num);  //num = 3

//或者
fn3 = function(){
    console.log("fn3")				
}

fn3() //fn3


/*********************
4、箭头函数：
主要作用是将里面的this指向最外层
**********************/
let fn5 = function(n){  //这是匿名函数
    return n
}

//以下是箭头函数
let fn6 = n => n
let fn7 = () => 10			
let fn8 = (n,m) => n+m			
let fn9 = (n,m) => {console.log("10");  return n+m}
console.log(fn6(100,9))  //100
console.log(fn7(100,9))  //10
console.log(fn8(100,9))  //109
console.log(fn9(100,9))  //10 109

/*********************
5、即时函数：
**********************/
//即时函数：这种函数可以在定以以后立即调用
//将匿名函数的定义放进一对小括号中，然后外面再紧跟一对小括号即可。最后的小括号起到的是"立即执行"的作用，同时它也是向匿名函数传递参数的地方。
(function(a){
    console.log("a = " + a);
})("sunck is a good man!");


/*********************
5、函数闭包：
**********************/
/*闭包：在外函数的内部定义了一个内函数，内函数使用了外函数的临时变量，
外函数的返回值是内函数的引用【内函数的函数名】，这时候就构成了一个闭包。

一般情况下当函数执行完毕，函数中所有的东西都会被释放掉还给内存，这时候局部变量也会消失，
但是当外函数结束的时候，发现自己还有临时变量在内函数中还会使用，此时外函数会将自己的临时变量
绑定内函数，自己再结束。*/

    //简单的闭包：创建闭包最常见的方式函数作为返回值
    function foo() {
      var name = "kebi";
      return function() {
        console.log(name);
      };
    }
    var bar = foo();
    bar(); //打印kebi    --外部函数访问内部变量


    //复杂点的闭包
    function addCount() {
      var conut = 0;
      return function() {
        count = count + 1;
        console.log(count);
      };
    }

    var fun1 = addCount();
    fun1(); //1
    fun1(); //2
    var fun2 = addCount();
    fun2(); //1
    fun2(); //2

	//再复杂点的闭包
    function outerfunc(){
        var arr =[]
        for(var i=0; i<10; i++){
            function inner(){
                return i
            }
            arr.push(inner)
        }

        return arr
    }

    var arr2 = outerfunc()
    for(var j=0; j<arr2.length; j++){
        console.log(arr2[j]())
    }
	//10个10
```



##### 四、数组对象、字符串对象、Math对象与Date对象

###### 1、数组对象

```javascript
一、数组对象：
    /*********************
    1、创建数组：
    **********************/
    //数组定义
    var arr = new Array()
    console.log(arr, typeof arr) //[] "object"

    var arr = new Array(3)  //创建长度为3的数组
    console.log(arr)  //[,,]

    var arr = new Array(3, 4)
    console.log(arr)  //[3, 4]

    var arr = [11, 33, 22]  //字面量定义数组
    console.log(arr)  //[11, 33, 22]
    console.log(arr[0])  //11
    console.log(arr[4])  //undefinded
    console.log(arr[arr.length-1])  //22


    /*********************
    2、遍历数组：
    **********************/
    var arr = [11, 33, 22] 
    console.log(arr.length)  //数组长度
    for(var i= 0; i< arr.length; i++){
        console.log(i, arr[i])
    }

    //改变数组的长度（增加）
    //其余元素默认值为undefined
    arr.length = 10;

    //改变数组的长度（减少）
    //多余的直接裁剪
    arr.length = 2;
    console.log(arr);

    //如果新元素添加的位置与原数组末端存在一定的间隔，
    //那么这之间的元素将会被自动设置为undefined值
    var arr = [11, 33, 22] 
    arr[5] = 10;
    console.log(arr.length);  //6
    console.log(arr);  //[11, 33, 22, empty × 2, 10]
    console.log("arr[3] = " + arr[3]); //arr[3] = undefined
    console.log("arr[4] = " + arr[4]);  //arr[4] = undefined

    //删除：用delete操作符删除特定的元素
    //原数组长度不会改变
    //删除元素的位置知识被留空了而已，为undefined值
    var arr = [11, 33, 22,"zs"] 
    delete arr[2];
    console.log(arr.length);  //4
    console.log(arr);  //[11, 33, empty, "zs"]
    console.log("arr[2] = " + arr[2]);  //arr[2] = undefined

    delete arr //不能删除
    arr = null
    console.log(arr);  //null

    /*********************
    3、数组常用方法：
    **********************/
    //1、push(item1,item2...)
    // 功能：向数组的末尾插入元素
    // 参数：一个或者多个数组元素
    // 返回值：数组改变之后的容量
    var arr1 = [1,2,3];
    var length1 = arr1.push(4,5);
    console.log("length1 = " + length1);  //length1 = 5
    console.log(arr1); //[1, 2, 3, 4, 5]


    //2、pop()
    // 功能：删除数组末尾的元素
    // 参数：无参
    // 返回值：删除的元素
    var arr3 = [1,2,3];
    var value3 = arr3.pop();
    console.log("value3 = " + value3);  //value3 = 3
    console.log(arr3); //[1, 2]
    //arr.pop(2) //不支持



    //3.shift();
    // 功能：删除数组头部的元素
    // 参数：无参
    // 返回值：删除的元素
    var arr4 = [1,2,3];
    var value4 = arr4.shift();
    console.log("value4 = " + value4);  //value4 = 1
    console.log(arr4);  //[2, 3]

    //4、unshift(item1,item2......)
    // 功能：向数组的头部插入元素
    // 参数：一个或者多个数组元素
    // 返回值：数组改变之后的容量
    var arr2 = [1,2,3];
    var length2 = arr2.unshift(-1,0);
    console.log("length2 = " + length2);  //length2 = 5
    console.log(arr2);   //[-1, 0, 1, 2, 3]

    //5、join(str)
    //功能：用参数字符串将数组中元素拼接成一个新字符串
    //参数：拼接使用的字符串,不设置参数则默认去掉[]
    //返回值：拼接后的字符串
    //不会改变原数组
    var arr5 = [1,2,3,4];
    var str5 = arr5.join("good");
    var str6 = arr5.join();
    console.log(arr5); //[1, 2, 3, 4]
    console.log(str5);  //1good2good3good4
    console.log(str6);  //1,2,3,4

    //6、reverse()
    //功能：将原数组元素倒置
    //参数：无
    //返回值：返回原数组
    //注意：原数组改变
    var arr6 = [1,2,3,4];
    var ret6 = arr6.reverse();
    console.log(arr6);  //[4, 3, 2, 1]
    console.log(ret6);  //[4, 3, 2, 1]

    //7.slice(startIndex,endIndex)
    // 功能：截取数组元素
    // 参数：开始下标(默认0)，结束下标(默认数组长度)[0,arr.length]
    // 返回值：截取到的数组元素组成的数组
    // 注意：
    // 1.不包括arr[endIndex]元素，范围 [startIndex,endIndex)
    // 2.原数组不会改变
    // 3.endIndex的值必须大于1并且不能小于startIndex的值
    var arr7 = [1,2,3,4,5,6,7,8];
    var ret7 = arr7.slice(0,6);  
    console.log("******");
    console.log(ret7);  //[1, 2, 3, 4, 5, 6]
    console.log(arr7); //[1, 2, 3, 4, 5, 6, 7, 8]

	var ret8 = arr7.slice();  //数组拷贝

    // 8.splice(下标,个数,item1,item2...)
    // 必须的参数：下标(开始位置) 个数
    // 可选的参数：item1,item2...
    // 功能：在数组中间插入或者删除数组元素，如果要插入元素的话，个数为0
    // 返回值：被删除的元素组成的数组

    //splice插入方式
    var arr8 = [1,2,3,4,5];
    var ret8 = arr8.splice(2, 0 , 8, 9);  ////从下标2开始的0个数删除,并将8, 9插入1的位置
    console.log(ret8);  //[]
    console.log(arr8);  // [1, 2, 8, 9, 3, 4, 5]

    //splice删除方式
    var arr8 = [1,2,3,4,5];
    ret8 = arr8.splice(3,2);
    console.log(ret8);  //[4, 5]
    console.log(arr8);  //[1, 2, 3]

    //splice改方式
    var arr = ['马斯克','马化腾','贝佐斯','马云','马克思']					
    ret8 = arr.splice(1, 3, '雷布斯','李彦宏')  //从下标1开始的3个数删除,并将后面2个元素插入
    console.log(ret8)  //["马化腾", "贝佐斯", "马云"]
    console.log(arr)  // ["马斯克", "雷布斯", "李彦宏", "马克思"]

    // 9、concat()
    // 功能：将两个数组拼接
    // 参数：一个或者多个数组
    // 返回值：新数组，数组元素是所有拼接的数组元素。
    // 注：对原数组没有影响。
    var arr9 = [1,2,3,4];
    var str9 = [8,9];
    var acp9 = [0,6,8];
    var ret9 = arr9.concat(str9, acp9);
    console.log(arr9);  //[1, 2, 3, 4]
    console.log(str9);  //[8, 9]
    console.log(acp9);  //[0, 6, 8]
    console.log(ret9);  //[1, 2, 3, 4, 8, 9, 0, 6, 8]

    //10、indexOf()
    //功能：从数组的头部查找数组元素，找到返回数组元素的下标，否则话返回-1.
    //参数：要查找的元素
    // 返回值：下标或者-1
    var arr10 = [1,2,3,3,5];
    var ret10 = arr10.indexOf(3);
    console.log(arr10);  //[1, 2, 3, 3, 5]
    console.log(ret10);  //2

    // 11.lastIndexOf()
    //功能：从数组的尾部查找数组元素，找到返回数组元素的下标，否则话返回-1.
    //参数：要查找的元素
    // 返回值：下标或者-1
    var arr11 = [1,2,3,3,5];
    var ret11 = arr11.lastIndexOf(3);
    console.log(arr11);  //[1, 2, 3, 3, 5]
    console.log(ret11);  //3

    //12.sort
    //功能:对数组元素进行排序,如果没有比较函数默认按字母的asii码排序
    //参数：比较函数
    //返回值：已排序数组
    //注:会影响原数组
    var arr = [22,11,3, 5, 4, 3, 6, 9,1]
    var ret = arr.sort()
    console.log(arr)  // [1, 11, 22, 3, 3, 4, 5, 6, 9]
    console.log(ret)  //[1, 11, 22, 3, 3, 4, 5, 6, 9]
    arr.sort(function(a, b){ return a-b})
    console.log(arr) // [1, 3, 3, 4, 5, 6, 9, 11, 22]

    arr.sort((a, b)=>a-b)
    console.log(arr) // [1, 3, 3, 4, 5, 6, 9, 11, 22]
```



###### 2、字符串对象及与json转换

```javascript
二、字符串对象：
    /*********************
    1、创建数组：
    **********************/
    var str1 = "i am a good man";   //这是String类型，是基本类型	
    var str2 = new String("i am a nice man"); //字符串对象，引用类型，Object

    console.log(typeof str1);  //string
    console.log(typeof str2);  //object 

    console.log(str1)  //i am a good man
    str1[2] ="w"    //字符串不可以修改
    console.log(str1)  //i am a good man

    //str1是String基本类型，当使用String的引用类型的属性与方法时，默认转换成Object类型
    console.log(str1.length);  //15
    console.log(str2.length);  //15
    //lenght是只读属性

    /*********************
    2、字符串常用方法：
    **********************/
    //1、charCodeAt(index)
    //获取指定下标的字符的ASCII码(Unicode)的十进制数
    //0 - 48, 9 - 57  A - 65  a - 97
    //返回值为0~65535之间的整数
    var str2 = "i m a good man";
    console.log(str2.charCodeAt(2));  //109
    console.log(str2.charCodeAt(5));  //32

    //2、String.fromCharCode(ASCII码)
    //将ASCII码转换成对应的字符
    var str3 = String.fromCharCode(97);
    console.log(str3);  //a
    //对象方法（实例方法） 对象名.XXX()
    //类方法(静态方法)  引用类型名.XXX()

    //3、字符串大小写转换，返回转换后的结果字符串
    //toUpperCase,toLowerCase
    console.log("hello".toUpperCase()) //HELLO
    console.log("HEDolf".toLowerCase())  //hedolf

    //4、替换子串
    //replace(被替换的子串, 新子串)
    //返回被替换的字符串
    //原字符串不变
    //注意：此时只能替换第一次出现的子串，如果想全替换需要正则
    var str = 'good boy Boy boy'
    console.log(str.replace('boy', 'girl'))  //good girl Boy boy
    console.log(str.replace(/boy/g, 'girl'))  //good girl Boy girl
    console.log(str.replace(/boy/gi, 'girl'))  //good girl girl girl
    //g:global,全局查找
    //i:ignore,忽略大小写

    //5、提取子串
    var str = "abcssdfdf"
    console.log(str.substring(1,3))  //'bc' 范围[1,3) 从参数1下标出开始截取到参数2下标之前(注意不包含参数2下标出的字符)
    console.log(str.substr(1,3))  //'bcs' 范围[1,3] 从参数1下标处开始截取参数2长度的字符串
    console.log(str.slice(1,3))  //'bc' 范围[1,3) 因字符串不能改变，所以与substring类似

    //6、查找字符串
    var str = "abcssdfdf"
    console.log(str.indexOf("abc"));  //0 查找字符串第一次出现的位置, 如果没找到则返回-1
    console.log(str.lastIndexOf("s"));  //4 查找字符串最后一次出现的位置, 如果没找到则返回-1


    //7、split:拆分,分割
    //作用：以参数1对字符串进行切割
	//以数组的形式返还，没有找到切割字符的返回原数组
    var str = "123*432tt*"
    var paramArr = str.split("?")
    var paramArr2 = str.split("*")
    console.log(paramArr)  //["123*432tt*"]
    console.log(paramArr2)  //["123", "432tt", ""]

    var str = "http://www.baidu.com?name=zhangsan&age=33"
    var param = str.slice(str.indexOf('?')+1)
    var paramArr = param.split('&')
    console.log(paramArr)  //["name=zhangsan", "age=33"]

    var obj = {}
    for(var i=0; i<paramArr.length; i++){
        var str2 = paramArr[i]
        var str2Arr = str2.split('=')
        obj[str2Arr[0]] = str2Arr[1]
    }		   
    console.log(obj)  //{name: "zhangsan", age: "33"}

    //8、trim/trimLeft/trimRight去除空格
    console.log("    aad  ff  ".trim()) //aad  ff //去除字符串左右两边空格
    console.log("    aad  ff  ".trimLeft()) //aad  ff   //去除字符串左边空格
    console.log("    aad  ff  ".trimRight()) //    aad  ff  //去除字符串右边空格

    console.log("*****aad  ff**".trim("*"))  //*****aad  ff** 无效,只能去除空格

    //9、repeat字符串重复
    //将字符串重复参数1遍
    var str = "123*"
    console.log(str.repeat(2))  //123*123*

    /*********************
    3、字符串与json之间的转换：
    **********************/
	
    //json字符串
    var str = '{"name":"lisi"}'

    //json对象形式
    var obj = {"name":"lisi"}

    //json序列化:将json对象=>json字符串
    var obj = {"name":"lisi"}
    console.log(obj.toString())
    var str = JSON.stringify(obj)
    console.log(str, typeof str)  //{"name":"lisi"} string

    //json解析:将json字符串=>将json对象
    var str = '{"name":"lisi"}'
    var obj = JSON.parse(str)
    console.log(obj, typeof obj)

```

###### 3、Math对象

```javascript
三、Math对象
		//四舍五入
		console.log(Math.round(3.6)); //4
		console.log(Math.round(-3.6)); //-4

		//向上取整
		console.log(Math.ceil(3.1));  //4
		console.log(Math.ceil(-3.1));  //-3

		//向下取整
		console.log(Math.floor(3.1));  //3
		console.log(Math.floor(-3.1));  //-4

		//取最大值
		console.log(Math.max(1,2,3,4,5));  //5

		//取最小值
		console.log(Math.min(1,2,3,4,5));  //1

		//绝对值
		console.log(Math.abs(-3.4));  //3.4

		//求x的y次方(x = 2, y = 3)
		console.log(Math.pow(2,3));  //8

		//开平方
		console.log(Math.sqrt(25));  //5

		//随机输出x~y之间的一个整数（包含x和y）
		console.log(parseInt(Math.random() * (6 - 2 + 1) + 2));

```



###### 4、Date对象

```javascript
   /*********************
    1、Date()函数：
    **********************/
    //1、直接用Date()函数
    //返回当前时间
    //注意：不论Date()是否带参数，返回的都是当前时间
    var date1 = Date("2016-09-18");
    console.log(typeof date1);//String类型
    console.log(date1);  //Sat Jul 20 2019 17:02:36 GMT+0800 (中国标准时间)


    //2、构造函数法--不传参数
    //返回系统当前时间
    var date2 = new Date();
    console.log(typeof date2);//Object类型
    console.log(date2.toLocaleString());  //2019/7/20 下午5:07:33 


    //3、构造函数法--参数是一个表示时间的字符串
    //3.1 格式：month day, year hours:minutes:seconds
    //December 24, 2008 12:04:13
    //注意：如果省略了小时、分钟、秒数，这些会被设置为0
    //3.2 2016-09-18 18:32:32    2016-9-18 18:32:32
    //3.3 2016/09/18 18:32:32
    var date3 = new Date("2016/09/18");  
    var date4 = new Date("2016-09-08");
    var date5 = new Date("2016-9-8");
    console.log(date3.toLocaleString())  //2016/9/18 上午12:00:00
    console.log(date4.toLocaleString())  //2016/9/8 上午8:00:00
    console.log(date5.toLocaleString())  //2016/9/8 上午8:00:00 后面的时间默认




    //4、构造函数法--参数是(年,月,日,时,分,秒,毫秒)
    //注意：年和月必须写，且月从0开始，日期从1开始
    var date6 = new Date(2016,09,9,10,10,10,1000);
    console.log(date6.toLocaleString());  //2016/10/9 上午10:10:11


    //5、构造函数法--参数是毫秒数
    //返回中国标准时间
    var date7 = new Date(1000);
    console.log(date7.toLocaleString());  //1970/1/1 上午8:00:01

    /*********************
    2、Date()函数常用方法：
    **********************/


    //创建日期
    var d = new Date()
    console.log(d)  //Sat Jul 20 2019 17:18:40 GMT+0800 (中国标准时间)
    console.log(d.toLocaleDateString())  //2019/7/20
    console.log(d.toLocaleTimeString())  //下午5:18:40
    console.log(d.toLocaleString())  //2019/7/20 下午5:18:40

    //时间戳
    var d = new Date()
    console.log(d.getTime())  //1563614320984  毫秒


    /*
            日期Date的常用方法:
            setDate() / getDate();   从Date对象中返回一个月中的某一天(1~31)
            getDay();   从Date对象返回一周中的某一天(0~6)
            set / getMonth();  从Date对象中返回月份(0~11)
            set / getFullYear();   从Date对象以四位数返回年份
            set / getHours();	  返回Date对象的小时(0~23)
            set / getMinutes();   返回Date对象的分钟(0~59)
            set / getSeconds();   返回Date对象的秒数(0~59)
            set / getMilliseconds();   返回Date对象的毫秒
            set / getTime();   返回1970年1月1日至今的毫秒数
            */	
    var d = new Date()
    console.log(d.getFullYear())  //2019
    console.log(d.getMonth())  //6,表示7月份
    console.log(d.getDate())  
    console.log(d.getHours())  
    console.log(d.getMinutes())
    console.log(d.getSeconds())	


    //时间差
    var d1 = new Date("2019/10/10")
    var d2 = new Date("2019/11/1")
    console.log(d2-d1)  //毫秒
    console.log((d2-d1)/(1000*60*60*24))  //22天
```



##### 五、面向对象与原型

```javascript
一、面向对象：
    /*********************
    1、创建对象：
    Object、字面量：{}
    **********************/
    var person = new Object(); //Object创建对象
    person.name = "zhaoss"; 	//创建一个name属性并赋值
    person.age = 22;	//创建一个age属性并赋值
    person.run = function () {		//创建一个run()方法并返回值
        return this.name + this.age + '运行中...';
    };
    console.log(obj.run());

	console.log("*".repeat(10));

    var person = {    //字面量创建对象
        name:"zhaoss",
        age:22,
        run:function(){
            return this.name + this.age + '运行中...';
        }
    } 

    
    /*********************
    2、数据属性与访问器属性 
    **********************/        
        /* 
        1、数据属性：
            configurable
            enumberable
            writable
            value
            通过Object.defineProperty(参数1,参数2,参数3)设置
            参数1:属性所在的对象
            参数2：属性名
            参数3：描述符对象
            调用Object.defineProperty(参数1,参数2,参数3)时，
            configurable、enumberable、writable默认为false
        */
        var person = {}	
        Object.defineProperty(person, "name", {
            writable:false,
            value:"add"
        })

        console.log(person.name)  //add	
        person.name = "ffd"
        console.log(person.name)	//add

    console.log("*".repeat(10))  //****************

        var person1 = {}	
        Object.defineProperty(person1, "name", {
            configurable: false,   //一旦设置属性name为不可配置,就不能再把它变回可配置了,再配置会报错
            value:"wqe"
        })

        console.log(person1.name)  //wqe	
        delete person.name 
        console.log(person1.name)	//wqe

        Object.defineProperty(person1, "name", {
            configurable: true,  //报错
            value:"ttt"
        })


        /* 
        2、访问器属性：(get、set函数)
        	属性前面加_语义上为私有属性
            configurable
            enumberable（是否可以通过for-in返回属性）
            get
            set
            通过Object.defineProperty(参数1,参数2,参数3)设置
            参数1:属性所在的对象
            参数2：属性别名
            参数3：描述符对象
            或者使用下面的设置get、set方法
            book.__defineGetter__(参数1,参数2)
            book.__defineSetter__(参数1,参数2)
            参数1：属性别名
            参数2：get/set函数
        */
        var book = {
            _year: 2004,
            edition: 1
        }

        Object.defineProperty(book, "year", {
            get:function(){
                return this._year
            },
            set: function(newvalue){
                if(newvalue>2004){
                    this._year = newvalue;
                    this.edition += newvalue - 2004
                }
            }
        })
	//或者
        book.year = 2005;
        console.log(book.edition)  //2

        book.__defineGetter__("year",function(){ return this._year} )
        book.__defineSetter__("year",function(newvalue){
            if(newvalue>2004){
                this._year = newvalue;
                this.edition += newvalue - 2004
            }
        } )

	//定义多个属性，使用Object.defineProperties方法
        var book = {}
        Object.defineProperties(book,{
            _year:{
                writable:true,
                value:2004
            },

            edition:{
                writable:true,
                value:1
            },

            year:{
                get:function(){
                    return this._year
                },

                set: function(newvalue){
                    if(newvalue>2004){
                        this._year = newvalue;
                        this.edition += newvalue - 2004
                    }
                }
            }
        })


        book.year = 2009;
        console.log(book.edition)  //6
        console.log(book.year)  //2009
        console.log(book._year)  //2009

二、构造函数
/*********************
 1、使用构造函数创建对象
**********************/  
    // 使用构造函数的方法，解决重复实例化的问题和对象识别的问题
    console.log("*******3*******");
    function Box(name,age){
        this.name=name;
        this.age=age;
        this.run=function(){
            console.log(this.name + this.age + '运行中...');
        }
    }

    var box3 = new Box('Lee', 100);			//new Box()即可
    var box4 = new Box('Jack', 200);
    console.log(typeof box3);  //object
    console.log(box3 instanceof Box);				//true 很清晰的识别他从属于Box
    console.log(box3 instanceof Object);		    //true 
    console.log(Box instanceof Object);				//true 
    // 1.当使用了构造函数，并且new 构造函数()，那么就后台执行了new Object()；
    // 2.将构造函数的作用域给新对象，(即new Object()创建出的对象)，
	//	而函数体内的this就代表new Object()出来的对象。
    // 3.执行构造函数内的代码；
    // 4.返回新对象(后台直接返回)。
	
	//不使用new,直接调用函数，this指向window,相当将函数里面的属性和方法添加到window对象中
	Box('Lee', 100)  
    console.log(window.name)  //zhangsan
    window.run()  //zhangsan14运行中...

/*********************
 2、使用构造函数创建对象的问题
 每个方法都要在每个实例上重新创建一遍
 1）、ECMAscript中的函数是对象
 2）、以构造函数创建的函数会导致不同的作用域链和标识符解析
 3）、创建两个完成同样任务的Function实例是没有必要的(做一件事只需定义一个函数就可以)
**********************/  
    function Box(name,age){
        this.name=name;
        this.age=age;
        this.run=function(){
            console.log(this.name + this.age + '运行中...');
        }
        //相当于：this.run = new Function("console.log(this.name + this.age + '运行中...')")
        
    }

    var box1 = new Box("zhangsan",14)
    var box2 = new Box("lisi",14)
    console.log(box1.run == box2.run)  //false


/*全局作用域定义函数:
解决的临时办法
将在构造函数里定义的函数定义在全局作用域里
以解决两个函数做同一件事的问题(做一件事只需定义一个函数就可以)

这种方法的问题:
如果对象需要定义很多方法,那么就需要定义很多全局函数,这样就没有丝毫封装性可言了
*/
    function Box(name,age){
        this.name=name;
        this.age=age;
        // this.run = new Function("console.log(this.name + this.age + '运行中...')")
        this.run=run
    }

    function run(){
        console.log(this.name + this.age + '运行中...');
    }

    var box1 = new Box("zhangsan",14)
    var box2 = new Box("lisi",14)
    console.log(box1.run == box2.run)  //true


三、原型模式
/*********************
 1、原型模式：
 原型属性prototype：
 我们创建的每个函数都有一个prototype(原型)属性，
 这个属性是一个指针指向一个对象，这个对象的用途是包含所有实例共享的属性和方法
 这个对象称为"原型对象"
 
 原型对象的constructor属性：所有原型对象都会自动获得一个constructor属性
 该属性指向原型对象所在的构造函数
 
 实例属性__proto__（ie浏览器没有该属性）：当我们创建实例时，每个实例都会获得一个__proto__属性，
 该属性指向原型属性prototype
 

 对ie可以使用isPrototypeOf()方法检测 对象实例是否跟原型存在关系
 var obj = new Box1()
 console.log(Box1.prototype.isPrototypeOf(obj))
 
 还可以通过Object.getPrototypeOf()获取实例的[[Prototype]](即__proto__)
 
  __proto__ 、Object.getPrototypeOf(实例)=> prototype(含constructor);
 constructor => 构造函数
**********************/  
    function Box1() {}							//声明一个构造函数

    Box1.prototype.name = 'Lee';					//在原型里添加对象共享属性
    Box1.prototype.age = 100;					
    Box1.prototype.run = function () {				//在原型里添加对象共享方法
        return this.name + this.age + '运行中...';
    };

    console.log(Box1.prototype)  //原型属性{name: "Lee", age: 100, run: ƒ, constructor: ƒ}
    console.log(Box1.prototype.constructor)  //ƒ Box1() {}
    console.log(Box1.prototype.constructor == Box1)  //true

    var obj = new Box1()		
    console.log(obj.__proto__ )  //{name: "Lee", age: 100, run: ƒ, constructor: ƒ},指向原型
    console.log(obj.__proto__ == Box1.prototype)  //true
    console.log(obj.__proto__.constructor == Box1)  //true
	console.log(Box1.prototype.isPrototypeOf(obj))  //true


    console.log(Object.getPrototypeOf(obj))  //{name: "Lee", age: 100, run: ƒ, constructor: ƒ}
    console.log(Object.getPrototypeOf(obj) === obj.__proto__)  //true
    console.log(Object.getPrototypeOf(obj) === Box1.prototype)  //true
	console.log(Object.getPrototypeOf(obj).name)  //Lee
/*********************
  2、简单的原型定义
  通过Person.prototype指向一个字面量自定义的一个实例，这个实例的constructor不再指向Person了，
  指向的是Object(),因此要重新指向Person类，如：constructor : Person  
  **********************/
function Person(){    
}

Person.prototype={
    constructor : Person, 
    name : "zhangsan",
    age : 18,
    say : function(){
    	console.log(this.name+this.age)
	},
}

/*********************
  3、原型的问题、组合使用构造函数和与原型模式
   原型中所有属性是被很多实例共享的，这种共享对于需共享的属性和函数非常合适，但是对于包含引用类型值的属性来说，就需要组合使用构造函数与和原型模式来定义
  **********************/
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.hobby = ["football","swimming"]
}

Person.prototype = {
    constructor:Person,
    say:function(){
        console.log(this.name+this.age);
    }
}


/*********************
  4、动态原型模式
  检查属性或者方法不存在的情况下，才去创建
  **********************/
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    
    if (typeof say != "function"){
        Person.prototype.say = function(){
        	console.log(this.name+this.age);
    	}
    }
}


/*********************
  5、寄生构造函数(工厂模式)
  **********************/
function Person(name, age){
    var obj = new Object()
    obj.name = name
    obj.age = age
    obj.say = function(){
        console.log(this.name+this.age)
    }
    
    return obj
}


四、继承
/*********************
  1、通过原型链实现继承
  **********************/
    function Animal(){  //父类
        this.name = "animal"
    }

    Animal.prototype.run = function(){  //父类方法
        return this.name+" is running";
    }

    function Cat(){  //子类定义
        this.name = "Cat"
    }

    Cat.prototype = new Animal();   //子类Cat继承父类Animal

    Cat.prototype.getname = function(){  //子类自定义方法
        return this.name
    }

    var cat1 = new Cat()
    var ani = new Animal()
    console.log(cat1.run())     //Cat is running
    console.log(cat1.getname()) //Cat

    Cat.prototype.run = function(){  //重写父类方法
        return this.name + " is do running"
    }		 
    console.log(cat1.run())  //Cat is do running


    console.log(Animal.prototype)  //{run: ƒ, constructor: ƒ} 字面量Object
    console.log(ani.__proto__)     //{run: ƒ, constructor: ƒ} 字面量Object
    console.log(Animal.prototype.constructor)  //ƒ Animal(){this.name = "animal"}
    console.log(ani.__proto__.constructor)     //ƒ Animal(){this.name = "animal"}

    console.log(Cat.prototype)  //Animal {name: "animal", getname: ƒ, run: ƒ}
    console.log(cat1.__proto__)  //Animal {name: "animal", getname: ƒ, run: ƒ}
    console.log(Cat.prototype.constructor)  //ƒ Animal(){this.name = "animal"}
    console.log(cat1.__proto__.constructor)  //ƒ Animal(){this.name = "animal"}


```



##### 六、BOM

```javascript
BOM的核心是window对象（全局）
window对象的方法:
  alert(text): 弹出提示框(警告框)
  confirm(): 创建一个需要用户确认的对话框
  prompt(text,defaultInput) : 创建一个对话框要求用户输入信息
  open(url,name,[options]) : 打开一个新窗口并返回新 window 对象

location对象中的方法：
 location.href = 'http://www.baidu.com'  //跳转到指定的URL
 location.reload();      //最有效的重新加载,有缓存加载


console.log(window)  //窗口对象
console.log(document)  //文档对象 dom

//在页面任意位置点击
document.onclick = function(){
    open("http://www.baidu.com")  //默认打开新窗口
    open("http://www.baidu.com","baidu")  //只打开一次新窗口
    open("http://www.baidu.com","_parent")  //在当前页面打开
}


// location对象
location.href = "http://www.baidu.com"  //在当前页面打开
location.reload() //刷新
location.reload(true) //清空缓存刷新


//history对象
history.back() //后退
history.forward()  //前进

//navigator对象
console.log(navigator.userAgent)  //用户代理
```



##### 七、定时器

```javascript
/*********************
 1、定时器：setInterval(函数名,时间)：
**********************/

//定时器：setInterval(函数名,时间)
// 功能：创建一个间歇性定时器，每间隔参数二时间执行一次参数一函数
// 返回值：定时器的id，可以通过该id关闭定时器
//定时器是异步的
//js定时器
//开启定时器 setInterval()
//关闭定时器:clearInterval()
var n =1;
var timer = setInterval(function(){
    console.log(n++)
    if(n > 10){
        clearInterval(timer)
    }
},500)

//顺序打印1-10


/*********************
 2、js延时器(异步)：setTimeout(函数名,时间)：
**********************/
//功能：参数2时间以后再执行参数1函数
//返回值：定时器的id
//js延时器(异步)
//开启延时器 setTimeout()
//关闭延时器:clearTimeout()
setTimeout(function(){
    console.log("jl")
},3000)

// 延时器实现定时器效果
var m = 1
function fn(){
    setTimeout(function(){
        console.log("强度"+ m++)
        if( m < 6) fn()
    },2000)
}
fn()



/*********************
 3、js延时器使用(异步)：setTimeout(函数名,时间)：
**********************/
for (var i = 0; i < 4; i++) {
  setTimeout(function() {
    console.log(i);
  }, 300);
}

//上边打印出来的都是 4, 可能部分人会认为打印的是 0,1,2,3
/*原因:js 执行的时候首先会先执行主线程,异步相关的会存到异步队列里,当主线程执行完毕开始执行异步队列, 主线程执行完毕后,此时 i 的值为 4,说以在执行异步队列的时候,打印出来的都是 4(这里需要大家对 event loop 有所了解(js 的事件循环机制))*/

//如何修改使其正常打印:(使用闭包使其正常打印)

//方法:（闭包，即时函数）
for (var i = 0; i < 4; i++) {
    setTimeout( 
        (
            function(i) {
                return function() {console.log(i);};
            }
        )(i),
        2000);
}
```



##### 八、DOM

```javascript
DOM的概念
      DOM就是Document  Object Model(文档对象模型)的缩写，DOM 是 W3C（万维网联盟）的标准。
      DOM是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。
      HTML-页面结构   css-页面样式    javascript –页面行为操作

DOM节点分类
DOM节点分为三种:  元素节点, 属性节点和文本节点
例如: <div title= "属性节点" >测试Div</div>
<div></div>:  元素节点(最重要)
title="属性节点":  属性节点
测试Div :  文本节点


1、元素节点对象的获取方式: 
         getElementById():  获取特定ID元素的节点对象(返回一个对象)
         getElementsByTagName():  获取指定标签名的节点列表(返回一个数组)
         getElementsByName():  获取相同name属性值的节点列表(返回一个数组)
         getElementsByClassName() : 通过class来获取节点列表


         
2、 getElementById()
    getElementById()需要给一个参数: 元素节点的id属性值。如果找到相应的元素则返回该元素的元素节点对象，如果不存在，则返回 null。
    例如: 获取 id 为 box 的元素节点
    var box = document.getElementById('box'); 

    注意: 如果id值存在, 但是返回null，则是执行顺序的问题
    解决方法:
    1. 把<script>标签(JS代码)移到html结构后面；
    2. 使用onload事件来处理， onload事件会在html加载完毕后再调用。 
    //加载 html 后执行 
    window.onload=function() {      
        document.getElementById('box');  //id具有唯一性
    };
      
3、js操作元素属性
    tagName: 元素节点对象所指向的标签名称(了解)
    innerHTML: 元素节点中的内容（重要）
    className: 元素节点的class属性值（重要）
    style: css内联样式对象（重要）
    children: 某元素的所有子元素节点
    value: 输入框的内容（重要）
    
    var box = document.getElementById('box')
    //获取相关元素属性
    console.log(box.innerHTML)
	console.log(box.className)
	console.log(box.value)
	console.log(box.src)
	console.log(box.offsetLeft, box.offsetTop)  // 位置 (只读)
	console.log(box.offsetWidth, box.offsetHeight)  // 大小(只读)

	//设置标签属性
    box.innerHTML="<b>aba</b>"
	box.className = 'pox'
	box.value="search"


4、js操作样式
	var box = document.getElementById('box')
	//获取指定元素样式
    console.log(window.getComputedStyle(box, null).width)  //宽度
	console.log(window.getComputedStyle(box, null).height)  //高度
	console.log(window.getComputedStyle(box, null).backgroundColor)  //背景色
	console.log(window.getComputedStyle(box, null).color)  //字体颜色
	console.log(window.getComputedStyle(box, null).fontSize)  //字体大小

	//设置指定元素样式
 	box.style.color = "red"
 	box.style.backgroundColor = "pink"
 	box.style.fontSize = "30px"


5、js操作元素
      createElement(); 创建一个元素节点
      appendChild(); 添加一个新子节点到子节点的末尾
      cloneNode(); 复制节点  true表示连子节点也复制
      removeChild(); 移除子节点
      remove(); 移除当前节点
 	
      //增加元素
      var box = document.getElementById('box')
      var div1 = document.createElement('div')  // <div></div>
	  box.appendChild(div1)
      
	  box.innerHTML = "<div><b>马斯克</b></div>"  //或者使用简单的方法


	 //克隆元素cloneNode
	 var box = document.getElementById('box')
 	 var box2 = box.cloneNode(true)
 	 document.body.appendChild(box2)  //向body增加该元素

    //删除子元素或者元素本身
	var box = document.getElementById('box')
     box.removeChild()  //删除子元素
     box.remove()  //删除元素本身

6、this关键字      
在JS事件中, this表示触发事件的元素节点对象;

var box = document.getElementById('box');  //返回对象，在对象里自己额外的方法
box.onclick = function() { 
      console.log(this);  //this表示box对象 
};

通过for循环添加事件, 使用this
var aInput = document.getElementsByTagName('input');
for (var i=0; i<aInput.length; i++) { 
        aInput[i].onclick = function() { 
                console.log(this.value);  //这里的this表示被点击的那个input元素节点对象 
        };
}
```



##### 九、事件

```javascript
事件的分类
      JavaScript 可以处理的事件种类有三种：鼠标事件, 键盘事件和 HTML事件.

一、鼠标事件
     鼠标事件，页面所有元素都可触发鼠标事件;

    1、click： 当单击鼠标按钮并在松开时触发
    div1 = document.getElementbyId('box')
    div1.onclick = function() { console.log('单击了鼠标'); };
    
	2、dblclick： 当双击鼠标按钮时触发。
    ondblclick = function() { console.log('双击了鼠标'); };
    
	3、mousedown：当按下了鼠标还未松开时触发。 
    onmousedown = function() { console.log('按下鼠标'); };


    4、mouseup： 释放鼠标按钮时触发。 
    onmouseup = function() {console.log('松开了鼠标'); };
    
	5、mousemove：当鼠标指针在某个元素上移动时触发。
    onmousemove = function() {console.log('鼠标移动了'); };  
    
	6、mouseenter：当鼠标移入某个元素的那一刻触发。
    onmouseenter = function() {console.log('鼠标移入了'); }; 

    7、mouseleave：当鼠标刚移出某个元素的那一刻触发。 
    onmouseleave = function() {console.log('鼠标移出了'); };


2. 键盘事件 
      键盘事件，在键盘上按下键时触发的事件; 
     (一般由window对象或者document对象调用)

    //键盘事件:按住不放会持续触发
    onkeydown = function(e){ console.log("rrrr", e.keyCode) }

    //包括:数字,字母,不包含:方向键,功能键shift/ctrl..
    onkeypress = function(e){ console.log("字符键按下", e.charCode) }

    //当用户释放键盘上的某个键触发
    onkeyup = function(){ console.log("松开按键") }


3. HTML事件 
      HTML事件，跟HTML页面相关的事件; 

load：当页面完全加载后触发
window.onload = function() { console.log('页面已经加载完毕'); };

change：当文本框(input 或 textarea)内容改变且失去焦点后触发。 
input.onchange = function() { console.log('文本框中内容改变了'); };


focus：当页面或者元素获得焦点时触发。 
input.onfocus = function() { console.log('文本框获得焦点'); };

blur：当页面或元素失去焦点时触发。
input.onblur = function() { console.log('文本框失去焦点'); };

scroll：当用户滚动带滚动条的元素时触发。
window.onscroll= function() { console.log('滚动了滚动条了'); };


4、事件对象Event
    通过事件的执行函数传入的event对象(事件对象) 不是在所有浏览器都有值,  在IE浏览器上event对象并没有传过来, 这里我们要用window.event来获取, 而在火狐浏览器上window.event无法获取, 而谷歌浏览器支持event事件传参和window.event两种, 为了兼容所有浏览器, 我们使用以下方式来得到event事件对象: 

box.onclick = function(evt){ 
     var e= evt || window.event; //获取到event对象(事件对象)
     console.log(e);
};

其中window.event中的window可以省略, 最终我们可以写成: 
box.onclick = function(evt){ 
     var e= evt || event; //获取到event对象(事件对象)
     console.log(e);
};

注意: evt||event不要倒过来写



事件对象Event的属性:

button: 鼠标按键
clientX: 浏览器可视区域的x坐标
clientY: 浏览器可视区域的y坐标
pageX: 浏览器内容区域的x坐标（重点）
pageY: 浏览器内容区域的y坐标
screenX: 显示器屏幕的x坐标（了解）
screenY: 显示器屏幕的y坐标
offsetX: 鼠标点击的元素位置距离元素左边界的x坐标（重点）
offsetY: 鼠标点击的元素位置距离元素上边界的y坐标


pageX = scrollLeft + clientX
pageY = scrollTop + clientY



5、阻止事件冒泡和默认行为
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<div id="box" style="width:300px; height: 100px; background: pink;">
			<input type="button" id="inpt"  value="按钮" />
		</div>
	</body>
	<script type="text/javascript">
		document.onclick = function(){
			console.log("document")
		}
		
		box.onclick = function(){
			console.log("div")
		}
		
		inpt.onclick = function(e){
			console.log("input")
			if(e.stopPropagation){
				e.stopPropagation();
			 }else{
				e.cancelBubble = true 
			 };
		}	
	</script>
</html>       
		
		//事件传递,事件冒泡
		//事件冒泡：一般浏览器都默认是使用事件冒泡,从子元素向父元素传递事件
		//事件捕获: 从父元素向子元素传递事件

一般我们只在指定的节点上添加事件, 而不想让其传递到下层节点触发事件, 这样我们就需要阻止事件冒泡;

阻止事件冒泡有两个方法: 
( 在指定不想再继续传递事件的节点的事件执行函数中使用)
1, 取消冒泡,  IE
     e.cancelBubble = true; 
2, 停止传播, 非IE
     e.stopPropagation(); 

例如: 
document.getElementsByTagName('input')[0].onclick= function(evt){
     var e = evt || window.event;
     //可以通过下述两个方法取消事件冒泡
     if(e.stopPropagation){
	e.stopPropagation();
     }else{
     	e.cancelBubble = true 
     };

    
    
阻止浏览器默认行为
    if (e.preventDefault) {
        e.preventDefault();   //非IE
    }
    else {
        e.returnValue = false;  // IE
    }

```

##### 十、js异步

```javascript
// JS
// Ajax(Asyc Javascript And XML): 阿贾克斯, 一个前端用来访问后端的技术
//	局部刷新(DOM操作), 异步请求
// Ajax的核心: XMLHttpRequest

btn1.onclick = function(){

	// 创建xhr对象
	var xhr = new XMLHttpRequest()

	// open: 准备一些参数
	// 第一个参数: http请求方式
	// 第二个参数: 接口,url,网址
	// 第三个参数: 是否异步请求
	xhr.open('GET', "json/person.json", true)
	
	// send: 发送HTTP请求
	xhr.send()
	
	// 接收服务器返回的数据
	xhr.onreadystatechange = function(){
		// 当readyState==4: 表示已经接受到数据
		// console.log(xhr.readyState)
		
		if (xhr.status == 200 && xhr.readyState == 4) {
			// 服务器响应的数据
			var res = xhr.responseText
			// console.log(res)
			console.log(JSON.parse(res))
		}
	}
}
```

